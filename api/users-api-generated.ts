/* tslint:disable */
/* eslint-disable */
/*
Appwrite

Appwrite backend as a service cuts up to 70% of the time and costs required for building a modern application. We abstract and simplify common development tasks behind a REST APIs, to help you develop your app in a fast and secure way. For full API documentation and tutorials go to [https://appwrite.io/docs](https://appwrite.io/docs)

The version of the OpenAPI document: 1.5.0
Contact: team@appwrite.io

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { IdentityList } from '../models';
// @ts-ignore
import { LogList } from '../models';
// @ts-ignore
import { MembershipList } from '../models';
// @ts-ignore
import { MfaFactors } from '../models';
// @ts-ignore
import { MfaRecoveryCodes } from '../models';
// @ts-ignore
import { Session } from '../models';
// @ts-ignore
import { SessionList } from '../models';
// @ts-ignore
import { Target } from '../models';
// @ts-ignore
import { TargetList } from '../models';
// @ts-ignore
import { Token } from '../models';
// @ts-ignore
import { UsageUsers } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { UserList } from '../models';
// @ts-ignore
import { UsersCreateArgonUserRequest } from '../models';
// @ts-ignore
import { UsersCreateBcryptPasswordRequest } from '../models';
// @ts-ignore
import { UsersCreateMd5UserRequest } from '../models';
// @ts-ignore
import { UsersCreateMessagingTargetRequest } from '../models';
// @ts-ignore
import { UsersCreateNewUserRequest } from '../models';
// @ts-ignore
import { UsersCreateScryptModifiedUserRequest } from '../models';
// @ts-ignore
import { UsersCreateScryptUserRequest } from '../models';
// @ts-ignore
import { UsersCreateWithPhPassRequest } from '../models';
// @ts-ignore
import { UsersCreateWithShaPasswordRequest } from '../models';
// @ts-ignore
import { UsersGenerateTokenRequest } from '../models';
// @ts-ignore
import { UsersUpdateEmailByIdRequest } from '../models';
// @ts-ignore
import { UsersUpdateEmailVerificationStatusRequest } from '../models';
// @ts-ignore
import { UsersUpdateLabelsByUserIdRequest } from '../models';
// @ts-ignore
import { UsersUpdateMessagingTargetRequest } from '../models';
// @ts-ignore
import { UsersUpdateMfaStatusRequest } from '../models';
// @ts-ignore
import { UsersUpdateNameByIdRequest } from '../models';
// @ts-ignore
import { UsersUpdatePasswordByUserIdRequest } from '../models';
// @ts-ignore
import { UsersUpdatePhoneByUserIdRequest } from '../models';
// @ts-ignore
import { UsersUpdatePhoneVerificationRequest } from '../models';
// @ts-ignore
import { UsersUpdatePrefsByIdRequest } from '../models';
// @ts-ignore
import { UsersUpdateStatusByUserIdRequest } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Argon2 password
         * @param {UsersCreateArgonUserRequest} [usersCreateArgonUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArgonUser: async (usersCreateArgonUserRequest?: UsersCreateArgonUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/argon2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateArgonUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/argon2',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateArgonUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with bcrypt password
         * @param {UsersCreateBcryptPasswordRequest} [usersCreateBcryptPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBcryptPassword: async (usersCreateBcryptPasswordRequest?: UsersCreateBcryptPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/bcrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateBcryptPasswordRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/bcrypt',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateBcryptPasswordRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with MD5 password
         * @param {UsersCreateMd5UserRequest} [usersCreateMd5UserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMD5User: async (usersCreateMd5UserRequest?: UsersCreateMd5UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/md5`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateMd5UserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/md5',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateMd5UserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a messaging target.
         * @summary Create User Target
         * @param {string} userId User ID.
         * @param {UsersCreateMessagingTargetRequest} [usersCreateMessagingTargetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessagingTarget: async (userId: string, usersCreateMessagingTargetRequest?: UsersCreateMessagingTargetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createMessagingTarget', 'userId', userId)
            const localVarPath = `/users/{userId}/targets`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateMessagingTargetRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateMessagingTargetRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
         * @summary Create MFA Recovery Codes
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMfaRecoveryCodes: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createMfaRecoveryCodes', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa/recovery-codes`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/recovery-codes',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.
         * @summary Create user
         * @param {UsersCreateNewUserRequest} [usersCreateNewUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewUser: async (usersCreateNewUserRequest?: UsersCreateNewUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateNewUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateNewUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt modified password
         * @param {UsersCreateScryptModifiedUserRequest} [usersCreateScryptModifiedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScryptModifiedUser: async (usersCreateScryptModifiedUserRequest?: UsersCreateScryptModifiedUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/scrypt-modified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateScryptModifiedUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/scrypt-modified',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateScryptModifiedUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt password
         * @param {UsersCreateScryptUserRequest} [usersCreateScryptUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScryptUser: async (usersCreateScryptUserRequest?: UsersCreateScryptUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/scrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateScryptUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/scrypt',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateScryptUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session for a user. Returns an immediately usable session object.  If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken) endpoint.
         * @summary Create session
         * @param {string} userId User ID. Choose a custom ID or generate a random ID with &#x60;ID.unique()&#x60;. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\&#39;t start with a special char. Max length is 36 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createSession', 'userId', userId)
            const localVarPath = `/users/{userId}/sessions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/sessions',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with PHPass password
         * @param {UsersCreateWithPhPassRequest} [usersCreateWithPhPassRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithPHPass: async (usersCreateWithPhPassRequest?: UsersCreateWithPhPassRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/phpass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateWithPhPassRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/phpass',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateWithPhPassRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with SHA password
         * @param {UsersCreateWithShaPasswordRequest} [usersCreateWithShaPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithShaPassword: async (usersCreateWithShaPasswordRequest?: UsersCreateWithShaPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/sha`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateWithShaPasswordRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/sha',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateWithShaPasswordRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an authenticator app.
         * @summary Delete Authenticator
         * @param {string} userId User ID.
         * @param {'totp'} type Type of authenticator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthenticator: async (userId: string, type: 'totp', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteAuthenticator', 'userId', userId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteAuthenticator', 'type', type)
            const localVarPath = `/users/{userId}/mfa/authenticators/{type}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type !== undefined ? type : `-type-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/authenticators/{type}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user by its unique ID, thereby releasing it\'s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus) endpoint instead.
         * @summary Delete user
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteById', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an identity by its unique ID.
         * @summary Delete identity
         * @param {string} identityId Identity ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityById: async (identityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteIdentityById', 'identityId', identityId)
            const localVarPath = `/users/identities/{identityId}`
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId !== undefined ? identityId : `-identityId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/identities/{identityId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user sessions by its unique ID.
         * @summary Delete user session
         * @param {string} userId User ID.
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionByUserIdAndSessionId: async (userId: string, sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteSessionByUserIdAndSessionId', 'userId', userId)
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteSessionByUserIdAndSessionId', 'sessionId', sessionId)
            const localVarPath = `/users/{userId}/sessions/{sessionId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId !== undefined ? sessionId : `-sessionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/sessions/{sessionId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all user\'s sessions by using the user\'s unique ID.
         * @summary Delete user sessions
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionsById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteSessionsById', 'userId', userId)
            const localVarPath = `/users/{userId}/sessions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/sessions',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a messaging target.
         * @summary Delete user target
         * @param {string} userId User ID.
         * @param {string} targetId Target ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTargetMessaging: async (userId: string, targetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTargetMessaging', 'userId', userId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('deleteTargetMessaging', 'targetId', targetId)
            const localVarPath = `/users/{userId}/targets/{targetId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"targetId"}}`, encodeURIComponent(String(targetId !== undefined ? targetId : `-targetId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets/{targetId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a token with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [PUT /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession) endpoint to complete the login process.
         * @summary Create token
         * @param {string} userId User ID.
         * @param {UsersGenerateTokenRequest} [usersGenerateTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateToken: async (userId: string, usersGenerateTokenRequest?: UsersGenerateTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('generateToken', 'userId', userId)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersGenerateTokenRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/tokens',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersGenerateTokenRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user activity logs list by its unique ID.
         * @summary List user logs
         * @param {string} userId User ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsByUserId: async (userId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getLogsByUserId', 'userId', userId)
            const localVarPath = `/users/{userId}/logs`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/logs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user membership list by its unique ID.
         * @summary List user memberships
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembershipsById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getMembershipsById', 'userId', userId)
            const localVarPath = `/users/{userId}/memberships`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/memberships',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Get MFA Recovery Codes
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMfaRecoveryCodes: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getMfaRecoveryCodes', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa/recovery-codes`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/recovery-codes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user\'s push notification target by ID.
         * @summary Get User Target
         * @param {string} userId User ID.
         * @param {string} targetId Target ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTarget: async (userId: string, targetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTarget', 'userId', userId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('getTarget', 'targetId', targetId)
            const localVarPath = `/users/{userId}/targets/{targetId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"targetId"}}`, encodeURIComponent(String(targetId !== undefined ? targetId : `-targetId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets/{targetId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users usage stats
         * @param {'24h' | '30d' | '90d'} [range] Date range.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageStats: async (range?: '24h' | '30d' | '90d', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/usage',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user by its unique ID.
         * @summary Get user
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user preferences by its unique ID.
         * @summary Get user preferences
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPrefsById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserPrefsById', 'userId', userId)
            const localVarPath = `/users/{userId}/prefs`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/prefs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the project\'s users. You can use the query params to filter your results.
         * @summary List users
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, email, phone, status, passwordUpdate, registration, emailVerification, phoneVerification, labels
         * @param {string} [search] Search term to filter your list results. Max length: 256 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFilteredUsers: async (queries?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get identities for all users.
         * @summary List Identities
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: userId, provider, providerUid, providerEmail, providerAccessTokenExpiry
         * @param {string} [search] Search term to filter your list results. Max length: 256 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentities: async (queries?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/identities',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the factors available on the account to be used as a MFA challange.
         * @summary List Factors
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMfaFactors: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listMfaFactors', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa/factors`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/factors',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user sessions list by its unique ID.
         * @summary List user sessions
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessionsByUserId: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listSessionsByUserId', 'userId', userId)
            const localVarPath = `/users/{userId}/sessions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/sessions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the messaging targets that are associated with a user.
         * @summary List User Targets
         * @param {string} userId User ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, email, phone, status, passwordUpdate, registration, emailVerification, phoneVerification, labels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTargets: async (userId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listTargets', 'userId', userId)
            const localVarPath = `/users/{userId}/targets`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Regenerate MFA Recovery Codes
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateMfaRecoveryCodesByUserId: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('regenerateMfaRecoveryCodesByUserId', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa/recovery-codes`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/recovery-codes',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user email by its unique ID.
         * @summary Update email
         * @param {string} userId User ID.
         * @param {UsersUpdateEmailByIdRequest} [usersUpdateEmailByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailById: async (userId: string, usersUpdateEmailByIdRequest?: UsersUpdateEmailByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEmailById', 'userId', userId)
            const localVarPath = `/users/{userId}/email`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateEmailByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/email',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateEmailByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user email verification status by its unique ID.
         * @summary Update email verification
         * @param {string} userId User ID.
         * @param {UsersUpdateEmailVerificationStatusRequest} [usersUpdateEmailVerificationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailVerificationStatus: async (userId: string, usersUpdateEmailVerificationStatusRequest?: UsersUpdateEmailVerificationStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEmailVerificationStatus', 'userId', userId)
            const localVarPath = `/users/{userId}/verification`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateEmailVerificationStatusRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/verification',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateEmailVerificationStatusRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user labels by its unique ID.   Labels can be used to grant access to resources. While teams are a way for user\'s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appwrite.io/docs/permissions) for more info.
         * @summary Update user labels
         * @param {string} userId User ID.
         * @param {UsersUpdateLabelsByUserIdRequest} [usersUpdateLabelsByUserIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLabelsByUserId: async (userId: string, usersUpdateLabelsByUserIdRequest?: UsersUpdateLabelsByUserIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateLabelsByUserId', 'userId', userId)
            const localVarPath = `/users/{userId}/labels`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateLabelsByUserIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/labels',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateLabelsByUserIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a messaging target.
         * @summary Update User target
         * @param {string} userId User ID.
         * @param {string} targetId Target ID.
         * @param {UsersUpdateMessagingTargetRequest} [usersUpdateMessagingTargetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessagingTarget: async (userId: string, targetId: string, usersUpdateMessagingTargetRequest?: UsersUpdateMessagingTargetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateMessagingTarget', 'userId', userId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('updateMessagingTarget', 'targetId', targetId)
            const localVarPath = `/users/{userId}/targets/{targetId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"targetId"}}`, encodeURIComponent(String(targetId !== undefined ? targetId : `-targetId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateMessagingTargetRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets/{targetId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateMessagingTargetRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable or disable MFA on a user account.
         * @summary Update MFA
         * @param {string} userId User ID.
         * @param {UsersUpdateMfaStatusRequest} [usersUpdateMfaStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMfaStatus: async (userId: string, usersUpdateMfaStatusRequest?: UsersUpdateMfaStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateMfaStatus', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateMfaStatusRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateMfaStatusRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user name by its unique ID.
         * @summary Update name
         * @param {string} userId User ID.
         * @param {UsersUpdateNameByIdRequest} [usersUpdateNameByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNameById: async (userId: string, usersUpdateNameByIdRequest?: UsersUpdateNameByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateNameById', 'userId', userId)
            const localVarPath = `/users/{userId}/name`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateNameByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/name',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateNameByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user password by its unique ID.
         * @summary Update password
         * @param {string} userId User ID.
         * @param {UsersUpdatePasswordByUserIdRequest} [usersUpdatePasswordByUserIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordByUserId: async (userId: string, usersUpdatePasswordByUserIdRequest?: UsersUpdatePasswordByUserIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePasswordByUserId', 'userId', userId)
            const localVarPath = `/users/{userId}/password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdatePasswordByUserIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/password',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdatePasswordByUserIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user phone by its unique ID.
         * @summary Update phone
         * @param {string} userId User ID.
         * @param {UsersUpdatePhoneByUserIdRequest} [usersUpdatePhoneByUserIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneByUserId: async (userId: string, usersUpdatePhoneByUserIdRequest?: UsersUpdatePhoneByUserIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePhoneByUserId', 'userId', userId)
            const localVarPath = `/users/{userId}/phone`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdatePhoneByUserIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/phone',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdatePhoneByUserIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user phone verification status by its unique ID.
         * @summary Update phone verification
         * @param {string} userId User ID.
         * @param {UsersUpdatePhoneVerificationRequest} [usersUpdatePhoneVerificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneVerification: async (userId: string, usersUpdatePhoneVerificationRequest?: UsersUpdatePhoneVerificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePhoneVerification', 'userId', userId)
            const localVarPath = `/users/{userId}/verification/phone`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdatePhoneVerificationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/verification/phone',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdatePhoneVerificationRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
         * @summary Update user preferences
         * @param {string} userId User ID.
         * @param {UsersUpdatePrefsByIdRequest} [usersUpdatePrefsByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrefsById: async (userId: string, usersUpdatePrefsByIdRequest?: UsersUpdatePrefsByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePrefsById', 'userId', userId)
            const localVarPath = `/users/{userId}/prefs`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdatePrefsByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/prefs',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdatePrefsByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user\'s ID reserved.
         * @summary Update user status
         * @param {string} userId User ID.
         * @param {UsersUpdateStatusByUserIdRequest} [usersUpdateStatusByUserIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusByUserId: async (userId: string, usersUpdateStatusByUserIdRequest?: UsersUpdateStatusByUserIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateStatusByUserId', 'userId', userId)
            const localVarPath = `/users/{userId}/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateStatusByUserIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/status',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateStatusByUserIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Argon2 password
         * @param {UsersApiCreateArgonUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArgonUser(requestParameters: UsersApiCreateArgonUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateArgonUserRequest: UsersCreateArgonUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArgonUser(usersCreateArgonUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with bcrypt password
         * @param {UsersApiCreateBcryptPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBcryptPassword(requestParameters: UsersApiCreateBcryptPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateBcryptPasswordRequest: UsersCreateBcryptPasswordRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBcryptPassword(usersCreateBcryptPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with MD5 password
         * @param {UsersApiCreateMD5UserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMD5User(requestParameters: UsersApiCreateMD5UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateMd5UserRequest: UsersCreateMd5UserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMD5User(usersCreateMd5UserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a messaging target.
         * @summary Create User Target
         * @param {UsersApiCreateMessagingTargetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessagingTarget(requestParameters: UsersApiCreateMessagingTargetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Target>> {
            const usersCreateMessagingTargetRequest: UsersCreateMessagingTargetRequest = {
                targetId: requestParameters.targetId,
                providerType: requestParameters.providerType,
                identifier: requestParameters.identifier,
                providerId: requestParameters.providerId,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessagingTarget(requestParameters.userId, usersCreateMessagingTargetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
         * @summary Create MFA Recovery Codes
         * @param {UsersApiCreateMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMfaRecoveryCodes(requestParameters: UsersApiCreateMfaRecoveryCodesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaRecoveryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMfaRecoveryCodes(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user.
         * @summary Create user
         * @param {UsersApiCreateNewUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewUser(requestParameters: UsersApiCreateNewUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateNewUserRequest: UsersCreateNewUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                phone: requestParameters.phone,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewUser(usersCreateNewUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt modified password
         * @param {UsersApiCreateScryptModifiedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScryptModifiedUser(requestParameters: UsersApiCreateScryptModifiedUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateScryptModifiedUserRequest: UsersCreateScryptModifiedUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                passwordSalt: requestParameters.passwordSalt,
                passwordSaltSeparator: requestParameters.passwordSaltSeparator,
                passwordSignerKey: requestParameters.passwordSignerKey,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScryptModifiedUser(usersCreateScryptModifiedUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt password
         * @param {UsersApiCreateScryptUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScryptUser(requestParameters: UsersApiCreateScryptUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateScryptUserRequest: UsersCreateScryptUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                passwordSalt: requestParameters.passwordSalt,
                passwordCpu: requestParameters.passwordCpu,
                passwordMemory: requestParameters.passwordMemory,
                passwordParallel: requestParameters.passwordParallel,
                passwordLength: requestParameters.passwordLength,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScryptUser(usersCreateScryptUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a session for a user. Returns an immediately usable session object.  If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken) endpoint.
         * @summary Create session
         * @param {UsersApiCreateSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(requestParameters: UsersApiCreateSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with PHPass password
         * @param {UsersApiCreateWithPHPassRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithPHPass(requestParameters: UsersApiCreateWithPHPassRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateWithPhPassRequest: UsersCreateWithPhPassRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWithPHPass(usersCreateWithPhPassRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with SHA password
         * @param {UsersApiCreateWithShaPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithShaPassword(requestParameters: UsersApiCreateWithShaPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateWithShaPasswordRequest: UsersCreateWithShaPasswordRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                passwordVersion: requestParameters.passwordVersion,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWithShaPassword(usersCreateWithShaPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an authenticator app.
         * @summary Delete Authenticator
         * @param {UsersApiDeleteAuthenticatorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthenticator(requestParameters: UsersApiDeleteAuthenticatorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthenticator(requestParameters.userId, requestParameters.type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user by its unique ID, thereby releasing it\'s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus) endpoint instead.
         * @summary Delete user
         * @param {UsersApiDeleteByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteById(requestParameters: UsersApiDeleteByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an identity by its unique ID.
         * @summary Delete identity
         * @param {UsersApiDeleteIdentityByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityById(requestParameters: UsersApiDeleteIdentityByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityById(requestParameters.identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user sessions by its unique ID.
         * @summary Delete user session
         * @param {UsersApiDeleteSessionByUserIdAndSessionIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionByUserIdAndSessionId(requestParameters: UsersApiDeleteSessionByUserIdAndSessionIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionByUserIdAndSessionId(requestParameters.userId, requestParameters.sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all user\'s sessions by using the user\'s unique ID.
         * @summary Delete user sessions
         * @param {UsersApiDeleteSessionsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionsById(requestParameters: UsersApiDeleteSessionsByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionsById(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a messaging target.
         * @summary Delete user target
         * @param {UsersApiDeleteTargetMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTargetMessaging(requestParameters: UsersApiDeleteTargetMessagingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTargetMessaging(requestParameters.userId, requestParameters.targetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a token with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [PUT /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession) endpoint to complete the login process.
         * @summary Create token
         * @param {UsersApiGenerateTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateToken(requestParameters: UsersApiGenerateTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const usersGenerateTokenRequest: UsersGenerateTokenRequest = {
                length: requestParameters.length,
                expire: requestParameters.expire
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateToken(requestParameters.userId, usersGenerateTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user activity logs list by its unique ID.
         * @summary List user logs
         * @param {UsersApiGetLogsByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogsByUserId(requestParameters: UsersApiGetLogsByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogsByUserId(requestParameters.userId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user membership list by its unique ID.
         * @summary List user memberships
         * @param {UsersApiGetMembershipsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembershipsById(requestParameters: UsersApiGetMembershipsByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembershipList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembershipsById(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Get MFA Recovery Codes
         * @param {UsersApiGetMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMfaRecoveryCodes(requestParameters: UsersApiGetMfaRecoveryCodesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaRecoveryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMfaRecoveryCodes(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user\'s push notification target by ID.
         * @summary Get User Target
         * @param {UsersApiGetTargetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTarget(requestParameters: UsersApiGetTargetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Target>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTarget(requestParameters.userId, requestParameters.targetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get users usage stats
         * @param {UsersApiGetUsageStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageStats(requestParameters: UsersApiGetUsageStatsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageUsers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageStats(requestParameters.range, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user by its unique ID.
         * @summary Get user
         * @param {UsersApiGetUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(requestParameters: UsersApiGetUserByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user preferences by its unique ID.
         * @summary Get user preferences
         * @param {UsersApiGetUserPrefsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPrefsById(requestParameters: UsersApiGetUserPrefsByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPrefsById(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all the project\'s users. You can use the query params to filter your results.
         * @summary List users
         * @param {UsersApiListFilteredUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFilteredUsers(requestParameters: UsersApiListFilteredUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFilteredUsers(requestParameters.queries, requestParameters.search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get identities for all users.
         * @summary List Identities
         * @param {UsersApiListIdentitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentities(requestParameters: UsersApiListIdentitiesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentities(requestParameters.queries, requestParameters.search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the factors available on the account to be used as a MFA challange.
         * @summary List Factors
         * @param {UsersApiListMfaFactorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMfaFactors(requestParameters: UsersApiListMfaFactorsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaFactors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMfaFactors(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user sessions list by its unique ID.
         * @summary List user sessions
         * @param {UsersApiListSessionsByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSessionsByUserId(requestParameters: UsersApiListSessionsByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSessionsByUserId(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the messaging targets that are associated with a user.
         * @summary List User Targets
         * @param {UsersApiListTargetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTargets(requestParameters: UsersApiListTargetsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTargets(requestParameters.userId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Regenerate MFA Recovery Codes
         * @param {UsersApiRegenerateMfaRecoveryCodesByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateMfaRecoveryCodesByUserId(requestParameters: UsersApiRegenerateMfaRecoveryCodesByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaRecoveryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateMfaRecoveryCodesByUserId(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user email by its unique ID.
         * @summary Update email
         * @param {UsersApiUpdateEmailByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailById(requestParameters: UsersApiUpdateEmailByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateEmailByIdRequest: UsersUpdateEmailByIdRequest = {
                email: requestParameters.email
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailById(requestParameters.userId, usersUpdateEmailByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user email verification status by its unique ID.
         * @summary Update email verification
         * @param {UsersApiUpdateEmailVerificationStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailVerificationStatus(requestParameters: UsersApiUpdateEmailVerificationStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateEmailVerificationStatusRequest: UsersUpdateEmailVerificationStatusRequest = {
                emailVerification: requestParameters.emailVerification
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailVerificationStatus(requestParameters.userId, usersUpdateEmailVerificationStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user labels by its unique ID.   Labels can be used to grant access to resources. While teams are a way for user\'s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appwrite.io/docs/permissions) for more info.
         * @summary Update user labels
         * @param {UsersApiUpdateLabelsByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLabelsByUserId(requestParameters: UsersApiUpdateLabelsByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateLabelsByUserIdRequest: UsersUpdateLabelsByUserIdRequest = {
                labels: requestParameters.labels
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLabelsByUserId(requestParameters.userId, usersUpdateLabelsByUserIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a messaging target.
         * @summary Update User target
         * @param {UsersApiUpdateMessagingTargetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessagingTarget(requestParameters: UsersApiUpdateMessagingTargetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Target>> {
            const usersUpdateMessagingTargetRequest: UsersUpdateMessagingTargetRequest = {
                identifier: requestParameters.identifier,
                providerId: requestParameters.providerId,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessagingTarget(requestParameters.userId, requestParameters.targetId, usersUpdateMessagingTargetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable or disable MFA on a user account.
         * @summary Update MFA
         * @param {UsersApiUpdateMfaStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMfaStatus(requestParameters: UsersApiUpdateMfaStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateMfaStatusRequest: UsersUpdateMfaStatusRequest = {
                mfa: requestParameters.mfa
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMfaStatus(requestParameters.userId, usersUpdateMfaStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user name by its unique ID.
         * @summary Update name
         * @param {UsersApiUpdateNameByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNameById(requestParameters: UsersApiUpdateNameByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateNameByIdRequest: UsersUpdateNameByIdRequest = {
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNameById(requestParameters.userId, usersUpdateNameByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user password by its unique ID.
         * @summary Update password
         * @param {UsersApiUpdatePasswordByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordByUserId(requestParameters: UsersApiUpdatePasswordByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdatePasswordByUserIdRequest: UsersUpdatePasswordByUserIdRequest = {
                password: requestParameters.password
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordByUserId(requestParameters.userId, usersUpdatePasswordByUserIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user phone by its unique ID.
         * @summary Update phone
         * @param {UsersApiUpdatePhoneByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoneByUserId(requestParameters: UsersApiUpdatePhoneByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdatePhoneByUserIdRequest: UsersUpdatePhoneByUserIdRequest = {
                number: requestParameters.number
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoneByUserId(requestParameters.userId, usersUpdatePhoneByUserIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user phone verification status by its unique ID.
         * @summary Update phone verification
         * @param {UsersApiUpdatePhoneVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoneVerification(requestParameters: UsersApiUpdatePhoneVerificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdatePhoneVerificationRequest: UsersUpdatePhoneVerificationRequest = {
                phoneVerification: requestParameters.phoneVerification
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoneVerification(requestParameters.userId, usersUpdatePhoneVerificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
         * @summary Update user preferences
         * @param {UsersApiUpdatePrefsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrefsById(requestParameters: UsersApiUpdatePrefsByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const usersUpdatePrefsByIdRequest: UsersUpdatePrefsByIdRequest = {
                prefs: requestParameters.prefs
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrefsById(requestParameters.userId, usersUpdatePrefsByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user\'s ID reserved.
         * @summary Update user status
         * @param {UsersApiUpdateStatusByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusByUserId(requestParameters: UsersApiUpdateStatusByUserIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateStatusByUserIdRequest: UsersUpdateStatusByUserIdRequest = {
                status: requestParameters.status
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusByUserId(requestParameters.userId, usersUpdateStatusByUserIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Argon2 password
         * @param {UsersApiCreateArgonUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArgonUser(requestParameters: UsersApiCreateArgonUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createArgonUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with bcrypt password
         * @param {UsersApiCreateBcryptPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBcryptPassword(requestParameters: UsersApiCreateBcryptPasswordRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createBcryptPassword(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with MD5 password
         * @param {UsersApiCreateMD5UserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMD5User(requestParameters: UsersApiCreateMD5UserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createMD5User(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a messaging target.
         * @summary Create User Target
         * @param {UsersApiCreateMessagingTargetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessagingTarget(requestParameters: UsersApiCreateMessagingTargetRequest, options?: AxiosRequestConfig): AxiosPromise<Target> {
            return localVarFp.createMessagingTarget(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
         * @summary Create MFA Recovery Codes
         * @param {UsersApiCreateMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMfaRecoveryCodes(requestParameters: UsersApiCreateMfaRecoveryCodesRequest, options?: AxiosRequestConfig): AxiosPromise<MfaRecoveryCodes> {
            return localVarFp.createMfaRecoveryCodes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Create user
         * @param {UsersApiCreateNewUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewUser(requestParameters: UsersApiCreateNewUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createNewUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt modified password
         * @param {UsersApiCreateScryptModifiedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScryptModifiedUser(requestParameters: UsersApiCreateScryptModifiedUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createScryptModifiedUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt password
         * @param {UsersApiCreateScryptUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScryptUser(requestParameters: UsersApiCreateScryptUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createScryptUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a session for a user. Returns an immediately usable session object.  If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken) endpoint.
         * @summary Create session
         * @param {UsersApiCreateSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(requestParameters: UsersApiCreateSessionRequest, options?: AxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.createSession(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with PHPass password
         * @param {UsersApiCreateWithPHPassRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithPHPass(requestParameters: UsersApiCreateWithPHPassRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createWithPHPass(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with SHA password
         * @param {UsersApiCreateWithShaPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithShaPassword(requestParameters: UsersApiCreateWithShaPasswordRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createWithShaPassword(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an authenticator app.
         * @summary Delete Authenticator
         * @param {UsersApiDeleteAuthenticatorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthenticator(requestParameters: UsersApiDeleteAuthenticatorRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.deleteAuthenticator(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user by its unique ID, thereby releasing it\'s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus) endpoint instead.
         * @summary Delete user
         * @param {UsersApiDeleteByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(requestParameters: UsersApiDeleteByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an identity by its unique ID.
         * @summary Delete identity
         * @param {UsersApiDeleteIdentityByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityById(requestParameters: UsersApiDeleteIdentityByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteIdentityById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user sessions by its unique ID.
         * @summary Delete user session
         * @param {UsersApiDeleteSessionByUserIdAndSessionIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionByUserIdAndSessionId(requestParameters: UsersApiDeleteSessionByUserIdAndSessionIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSessionByUserIdAndSessionId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all user\'s sessions by using the user\'s unique ID.
         * @summary Delete user sessions
         * @param {UsersApiDeleteSessionsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionsById(requestParameters: UsersApiDeleteSessionsByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSessionsById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a messaging target.
         * @summary Delete user target
         * @param {UsersApiDeleteTargetMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTargetMessaging(requestParameters: UsersApiDeleteTargetMessagingRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTargetMessaging(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a token with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [PUT /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession) endpoint to complete the login process.
         * @summary Create token
         * @param {UsersApiGenerateTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateToken(requestParameters: UsersApiGenerateTokenRequest, options?: AxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.generateToken(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user activity logs list by its unique ID.
         * @summary List user logs
         * @param {UsersApiGetLogsByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsByUserId(requestParameters: UsersApiGetLogsByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<LogList> {
            return localVarFp.getLogsByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user membership list by its unique ID.
         * @summary List user memberships
         * @param {UsersApiGetMembershipsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembershipsById(requestParameters: UsersApiGetMembershipsByIdRequest, options?: AxiosRequestConfig): AxiosPromise<MembershipList> {
            return localVarFp.getMembershipsById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Get MFA Recovery Codes
         * @param {UsersApiGetMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMfaRecoveryCodes(requestParameters: UsersApiGetMfaRecoveryCodesRequest, options?: AxiosRequestConfig): AxiosPromise<MfaRecoveryCodes> {
            return localVarFp.getMfaRecoveryCodes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user\'s push notification target by ID.
         * @summary Get User Target
         * @param {UsersApiGetTargetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTarget(requestParameters: UsersApiGetTargetRequest, options?: AxiosRequestConfig): AxiosPromise<Target> {
            return localVarFp.getTarget(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get users usage stats
         * @param {UsersApiGetUsageStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageStats(requestParameters: UsersApiGetUsageStatsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<UsageUsers> {
            return localVarFp.getUsageStats(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user by its unique ID.
         * @summary Get user
         * @param {UsersApiGetUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(requestParameters: UsersApiGetUserByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user preferences by its unique ID.
         * @summary Get user preferences
         * @param {UsersApiGetUserPrefsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPrefsById(requestParameters: UsersApiGetUserPrefsByIdRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getUserPrefsById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all the project\'s users. You can use the query params to filter your results.
         * @summary List users
         * @param {UsersApiListFilteredUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFilteredUsers(requestParameters: UsersApiListFilteredUsersRequest, options?: AxiosRequestConfig): AxiosPromise<UserList> {
            return localVarFp.listFilteredUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get identities for all users.
         * @summary List Identities
         * @param {UsersApiListIdentitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentities(requestParameters: UsersApiListIdentitiesRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityList> {
            return localVarFp.listIdentities(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the factors available on the account to be used as a MFA challange.
         * @summary List Factors
         * @param {UsersApiListMfaFactorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMfaFactors(requestParameters: UsersApiListMfaFactorsRequest, options?: AxiosRequestConfig): AxiosPromise<MfaFactors> {
            return localVarFp.listMfaFactors(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user sessions list by its unique ID.
         * @summary List user sessions
         * @param {UsersApiListSessionsByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessionsByUserId(requestParameters: UsersApiListSessionsByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<SessionList> {
            return localVarFp.listSessionsByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the messaging targets that are associated with a user.
         * @summary List User Targets
         * @param {UsersApiListTargetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTargets(requestParameters: UsersApiListTargetsRequest, options?: AxiosRequestConfig): AxiosPromise<TargetList> {
            return localVarFp.listTargets(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Regenerate MFA Recovery Codes
         * @param {UsersApiRegenerateMfaRecoveryCodesByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateMfaRecoveryCodesByUserId(requestParameters: UsersApiRegenerateMfaRecoveryCodesByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<MfaRecoveryCodes> {
            return localVarFp.regenerateMfaRecoveryCodesByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user email by its unique ID.
         * @summary Update email
         * @param {UsersApiUpdateEmailByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailById(requestParameters: UsersApiUpdateEmailByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateEmailById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user email verification status by its unique ID.
         * @summary Update email verification
         * @param {UsersApiUpdateEmailVerificationStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailVerificationStatus(requestParameters: UsersApiUpdateEmailVerificationStatusRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateEmailVerificationStatus(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user labels by its unique ID.   Labels can be used to grant access to resources. While teams are a way for user\'s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appwrite.io/docs/permissions) for more info.
         * @summary Update user labels
         * @param {UsersApiUpdateLabelsByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLabelsByUserId(requestParameters: UsersApiUpdateLabelsByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateLabelsByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a messaging target.
         * @summary Update User target
         * @param {UsersApiUpdateMessagingTargetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessagingTarget(requestParameters: UsersApiUpdateMessagingTargetRequest, options?: AxiosRequestConfig): AxiosPromise<Target> {
            return localVarFp.updateMessagingTarget(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable or disable MFA on a user account.
         * @summary Update MFA
         * @param {UsersApiUpdateMfaStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMfaStatus(requestParameters: UsersApiUpdateMfaStatusRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateMfaStatus(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user name by its unique ID.
         * @summary Update name
         * @param {UsersApiUpdateNameByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNameById(requestParameters: UsersApiUpdateNameByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateNameById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user password by its unique ID.
         * @summary Update password
         * @param {UsersApiUpdatePasswordByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordByUserId(requestParameters: UsersApiUpdatePasswordByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updatePasswordByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user phone by its unique ID.
         * @summary Update phone
         * @param {UsersApiUpdatePhoneByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneByUserId(requestParameters: UsersApiUpdatePhoneByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updatePhoneByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user phone verification status by its unique ID.
         * @summary Update phone verification
         * @param {UsersApiUpdatePhoneVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneVerification(requestParameters: UsersApiUpdatePhoneVerificationRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updatePhoneVerification(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
         * @summary Update user preferences
         * @param {UsersApiUpdatePrefsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrefsById(requestParameters: UsersApiUpdatePrefsByIdRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updatePrefsById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user\'s ID reserved.
         * @summary Update user status
         * @param {UsersApiUpdateStatusByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusByUserId(requestParameters: UsersApiUpdateStatusByUserIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateStatusByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createArgonUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateArgonUserRequest
 */
export type UsersApiCreateArgonUserRequest = {
    
} & UsersCreateArgonUserRequest

/**
 * Request parameters for createBcryptPassword operation in UsersApi.
 * @export
 * @interface UsersApiCreateBcryptPasswordRequest
 */
export type UsersApiCreateBcryptPasswordRequest = {
    
} & UsersCreateBcryptPasswordRequest

/**
 * Request parameters for createMD5User operation in UsersApi.
 * @export
 * @interface UsersApiCreateMD5UserRequest
 */
export type UsersApiCreateMD5UserRequest = {
    
} & UsersCreateMd5UserRequest

/**
 * Request parameters for createMessagingTarget operation in UsersApi.
 * @export
 * @interface UsersApiCreateMessagingTargetRequest
 */
export type UsersApiCreateMessagingTargetRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiCreateMessagingTarget
    */
    readonly userId: string
    
} & UsersCreateMessagingTargetRequest

/**
 * Request parameters for createMfaRecoveryCodes operation in UsersApi.
 * @export
 * @interface UsersApiCreateMfaRecoveryCodesRequest
 */
export type UsersApiCreateMfaRecoveryCodesRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiCreateMfaRecoveryCodes
    */
    readonly userId: string
    
}

/**
 * Request parameters for createNewUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateNewUserRequest
 */
export type UsersApiCreateNewUserRequest = {
    
} & UsersCreateNewUserRequest

/**
 * Request parameters for createScryptModifiedUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateScryptModifiedUserRequest
 */
export type UsersApiCreateScryptModifiedUserRequest = {
    
} & UsersCreateScryptModifiedUserRequest

/**
 * Request parameters for createScryptUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateScryptUserRequest
 */
export type UsersApiCreateScryptUserRequest = {
    
} & UsersCreateScryptUserRequest

/**
 * Request parameters for createSession operation in UsersApi.
 * @export
 * @interface UsersApiCreateSessionRequest
 */
export type UsersApiCreateSessionRequest = {
    
    /**
    * User ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\'t start with a special char. Max length is 36 chars.
    * @type {string}
    * @memberof UsersApiCreateSession
    */
    readonly userId: string
    
}

/**
 * Request parameters for createWithPHPass operation in UsersApi.
 * @export
 * @interface UsersApiCreateWithPHPassRequest
 */
export type UsersApiCreateWithPHPassRequest = {
    
} & UsersCreateWithPhPassRequest

/**
 * Request parameters for createWithShaPassword operation in UsersApi.
 * @export
 * @interface UsersApiCreateWithShaPasswordRequest
 */
export type UsersApiCreateWithShaPasswordRequest = {
    
} & UsersCreateWithShaPasswordRequest

/**
 * Request parameters for deleteAuthenticator operation in UsersApi.
 * @export
 * @interface UsersApiDeleteAuthenticatorRequest
 */
export type UsersApiDeleteAuthenticatorRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteAuthenticator
    */
    readonly userId: string
    
    /**
    * Type of authenticator.
    * @type {'totp'}
    * @memberof UsersApiDeleteAuthenticator
    */
    readonly type: 'totp'
    
}

/**
 * Request parameters for deleteById operation in UsersApi.
 * @export
 * @interface UsersApiDeleteByIdRequest
 */
export type UsersApiDeleteByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteById
    */
    readonly userId: string
    
}

/**
 * Request parameters for deleteIdentityById operation in UsersApi.
 * @export
 * @interface UsersApiDeleteIdentityByIdRequest
 */
export type UsersApiDeleteIdentityByIdRequest = {
    
    /**
    * Identity ID.
    * @type {string}
    * @memberof UsersApiDeleteIdentityById
    */
    readonly identityId: string
    
}

/**
 * Request parameters for deleteSessionByUserIdAndSessionId operation in UsersApi.
 * @export
 * @interface UsersApiDeleteSessionByUserIdAndSessionIdRequest
 */
export type UsersApiDeleteSessionByUserIdAndSessionIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteSessionByUserIdAndSessionId
    */
    readonly userId: string
    
    /**
    * Session ID.
    * @type {string}
    * @memberof UsersApiDeleteSessionByUserIdAndSessionId
    */
    readonly sessionId: string
    
}

/**
 * Request parameters for deleteSessionsById operation in UsersApi.
 * @export
 * @interface UsersApiDeleteSessionsByIdRequest
 */
export type UsersApiDeleteSessionsByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteSessionsById
    */
    readonly userId: string
    
}

/**
 * Request parameters for deleteTargetMessaging operation in UsersApi.
 * @export
 * @interface UsersApiDeleteTargetMessagingRequest
 */
export type UsersApiDeleteTargetMessagingRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteTargetMessaging
    */
    readonly userId: string
    
    /**
    * Target ID.
    * @type {string}
    * @memberof UsersApiDeleteTargetMessaging
    */
    readonly targetId: string
    
}

/**
 * Request parameters for generateToken operation in UsersApi.
 * @export
 * @interface UsersApiGenerateTokenRequest
 */
export type UsersApiGenerateTokenRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGenerateToken
    */
    readonly userId: string
    
} & UsersGenerateTokenRequest

/**
 * Request parameters for getLogsByUserId operation in UsersApi.
 * @export
 * @interface UsersApiGetLogsByUserIdRequest
 */
export type UsersApiGetLogsByUserIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetLogsByUserId
    */
    readonly userId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
    * @type {Array<string>}
    * @memberof UsersApiGetLogsByUserId
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for getMembershipsById operation in UsersApi.
 * @export
 * @interface UsersApiGetMembershipsByIdRequest
 */
export type UsersApiGetMembershipsByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetMembershipsById
    */
    readonly userId: string
    
}

/**
 * Request parameters for getMfaRecoveryCodes operation in UsersApi.
 * @export
 * @interface UsersApiGetMfaRecoveryCodesRequest
 */
export type UsersApiGetMfaRecoveryCodesRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetMfaRecoveryCodes
    */
    readonly userId: string
    
}

/**
 * Request parameters for getTarget operation in UsersApi.
 * @export
 * @interface UsersApiGetTargetRequest
 */
export type UsersApiGetTargetRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetTarget
    */
    readonly userId: string
    
    /**
    * Target ID.
    * @type {string}
    * @memberof UsersApiGetTarget
    */
    readonly targetId: string
    
}

/**
 * Request parameters for getUsageStats operation in UsersApi.
 * @export
 * @interface UsersApiGetUsageStatsRequest
 */
export type UsersApiGetUsageStatsRequest = {
    
    /**
    * Date range.
    * @type {'24h' | '30d' | '90d'}
    * @memberof UsersApiGetUsageStats
    */
    readonly range?: '24h' | '30d' | '90d'
    
}

/**
 * Request parameters for getUserById operation in UsersApi.
 * @export
 * @interface UsersApiGetUserByIdRequest
 */
export type UsersApiGetUserByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetUserById
    */
    readonly userId: string
    
}

/**
 * Request parameters for getUserPrefsById operation in UsersApi.
 * @export
 * @interface UsersApiGetUserPrefsByIdRequest
 */
export type UsersApiGetUserPrefsByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetUserPrefsById
    */
    readonly userId: string
    
}

/**
 * Request parameters for listFilteredUsers operation in UsersApi.
 * @export
 * @interface UsersApiListFilteredUsersRequest
 */
export type UsersApiListFilteredUsersRequest = {
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, email, phone, status, passwordUpdate, registration, emailVerification, phoneVerification, labels
    * @type {Array<string>}
    * @memberof UsersApiListFilteredUsers
    */
    readonly queries?: Array<string>
    
    /**
    * Search term to filter your list results. Max length: 256 chars.
    * @type {string}
    * @memberof UsersApiListFilteredUsers
    */
    readonly search?: string
    
}

/**
 * Request parameters for listIdentities operation in UsersApi.
 * @export
 * @interface UsersApiListIdentitiesRequest
 */
export type UsersApiListIdentitiesRequest = {
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: userId, provider, providerUid, providerEmail, providerAccessTokenExpiry
    * @type {Array<string>}
    * @memberof UsersApiListIdentities
    */
    readonly queries?: Array<string>
    
    /**
    * Search term to filter your list results. Max length: 256 chars.
    * @type {string}
    * @memberof UsersApiListIdentities
    */
    readonly search?: string
    
}

/**
 * Request parameters for listMfaFactors operation in UsersApi.
 * @export
 * @interface UsersApiListMfaFactorsRequest
 */
export type UsersApiListMfaFactorsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiListMfaFactors
    */
    readonly userId: string
    
}

/**
 * Request parameters for listSessionsByUserId operation in UsersApi.
 * @export
 * @interface UsersApiListSessionsByUserIdRequest
 */
export type UsersApiListSessionsByUserIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiListSessionsByUserId
    */
    readonly userId: string
    
}

/**
 * Request parameters for listTargets operation in UsersApi.
 * @export
 * @interface UsersApiListTargetsRequest
 */
export type UsersApiListTargetsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiListTargets
    */
    readonly userId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, email, phone, status, passwordUpdate, registration, emailVerification, phoneVerification, labels
    * @type {Array<string>}
    * @memberof UsersApiListTargets
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for regenerateMfaRecoveryCodesByUserId operation in UsersApi.
 * @export
 * @interface UsersApiRegenerateMfaRecoveryCodesByUserIdRequest
 */
export type UsersApiRegenerateMfaRecoveryCodesByUserIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiRegenerateMfaRecoveryCodesByUserId
    */
    readonly userId: string
    
}

/**
 * Request parameters for updateEmailById operation in UsersApi.
 * @export
 * @interface UsersApiUpdateEmailByIdRequest
 */
export type UsersApiUpdateEmailByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateEmailById
    */
    readonly userId: string
    
} & UsersUpdateEmailByIdRequest

/**
 * Request parameters for updateEmailVerificationStatus operation in UsersApi.
 * @export
 * @interface UsersApiUpdateEmailVerificationStatusRequest
 */
export type UsersApiUpdateEmailVerificationStatusRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateEmailVerificationStatus
    */
    readonly userId: string
    
} & UsersUpdateEmailVerificationStatusRequest

/**
 * Request parameters for updateLabelsByUserId operation in UsersApi.
 * @export
 * @interface UsersApiUpdateLabelsByUserIdRequest
 */
export type UsersApiUpdateLabelsByUserIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateLabelsByUserId
    */
    readonly userId: string
    
} & UsersUpdateLabelsByUserIdRequest

/**
 * Request parameters for updateMessagingTarget operation in UsersApi.
 * @export
 * @interface UsersApiUpdateMessagingTargetRequest
 */
export type UsersApiUpdateMessagingTargetRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateMessagingTarget
    */
    readonly userId: string
    
    /**
    * Target ID.
    * @type {string}
    * @memberof UsersApiUpdateMessagingTarget
    */
    readonly targetId: string
    
} & UsersUpdateMessagingTargetRequest

/**
 * Request parameters for updateMfaStatus operation in UsersApi.
 * @export
 * @interface UsersApiUpdateMfaStatusRequest
 */
export type UsersApiUpdateMfaStatusRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateMfaStatus
    */
    readonly userId: string
    
} & UsersUpdateMfaStatusRequest

/**
 * Request parameters for updateNameById operation in UsersApi.
 * @export
 * @interface UsersApiUpdateNameByIdRequest
 */
export type UsersApiUpdateNameByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateNameById
    */
    readonly userId: string
    
} & UsersUpdateNameByIdRequest

/**
 * Request parameters for updatePasswordByUserId operation in UsersApi.
 * @export
 * @interface UsersApiUpdatePasswordByUserIdRequest
 */
export type UsersApiUpdatePasswordByUserIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdatePasswordByUserId
    */
    readonly userId: string
    
} & UsersUpdatePasswordByUserIdRequest

/**
 * Request parameters for updatePhoneByUserId operation in UsersApi.
 * @export
 * @interface UsersApiUpdatePhoneByUserIdRequest
 */
export type UsersApiUpdatePhoneByUserIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdatePhoneByUserId
    */
    readonly userId: string
    
} & UsersUpdatePhoneByUserIdRequest

/**
 * Request parameters for updatePhoneVerification operation in UsersApi.
 * @export
 * @interface UsersApiUpdatePhoneVerificationRequest
 */
export type UsersApiUpdatePhoneVerificationRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdatePhoneVerification
    */
    readonly userId: string
    
} & UsersUpdatePhoneVerificationRequest

/**
 * Request parameters for updatePrefsById operation in UsersApi.
 * @export
 * @interface UsersApiUpdatePrefsByIdRequest
 */
export type UsersApiUpdatePrefsByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdatePrefsById
    */
    readonly userId: string
    
} & UsersUpdatePrefsByIdRequest

/**
 * Request parameters for updateStatusByUserId operation in UsersApi.
 * @export
 * @interface UsersApiUpdateStatusByUserIdRequest
 */
export type UsersApiUpdateStatusByUserIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateStatusByUserId
    */
    readonly userId: string
    
} & UsersUpdateStatusByUserIdRequest

/**
 * UsersApiGenerated - object-oriented interface
 * @export
 * @class UsersApiGenerated
 * @extends {BaseAPI}
 */
export class UsersApiGenerated extends BaseAPI {
    /**
     * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with Argon2 password
     * @param {UsersApiCreateArgonUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createArgonUser(requestParameters: UsersApiCreateArgonUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createArgonUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with bcrypt password
     * @param {UsersApiCreateBcryptPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createBcryptPassword(requestParameters: UsersApiCreateBcryptPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createBcryptPassword(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with MD5 password
     * @param {UsersApiCreateMD5UserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createMD5User(requestParameters: UsersApiCreateMD5UserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createMD5User(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a messaging target.
     * @summary Create User Target
     * @param {UsersApiCreateMessagingTargetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createMessagingTarget(requestParameters: UsersApiCreateMessagingTargetRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createMessagingTarget(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
     * @summary Create MFA Recovery Codes
     * @param {UsersApiCreateMfaRecoveryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createMfaRecoveryCodes(requestParameters: UsersApiCreateMfaRecoveryCodesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createMfaRecoveryCodes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user.
     * @summary Create user
     * @param {UsersApiCreateNewUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createNewUser(requestParameters: UsersApiCreateNewUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createNewUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with Scrypt modified password
     * @param {UsersApiCreateScryptModifiedUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createScryptModifiedUser(requestParameters: UsersApiCreateScryptModifiedUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createScryptModifiedUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with Scrypt password
     * @param {UsersApiCreateScryptUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createScryptUser(requestParameters: UsersApiCreateScryptUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createScryptUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a session for a user. Returns an immediately usable session object.  If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken) endpoint.
     * @summary Create session
     * @param {UsersApiCreateSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createSession(requestParameters: UsersApiCreateSessionRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createSession(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with PHPass password
     * @param {UsersApiCreateWithPHPassRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createWithPHPass(requestParameters: UsersApiCreateWithPHPassRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createWithPHPass(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with SHA password
     * @param {UsersApiCreateWithShaPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createWithShaPassword(requestParameters: UsersApiCreateWithShaPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createWithShaPassword(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an authenticator app.
     * @summary Delete Authenticator
     * @param {UsersApiDeleteAuthenticatorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteAuthenticator(requestParameters: UsersApiDeleteAuthenticatorRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteAuthenticator(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user by its unique ID, thereby releasing it\'s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus) endpoint instead.
     * @summary Delete user
     * @param {UsersApiDeleteByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteById(requestParameters: UsersApiDeleteByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an identity by its unique ID.
     * @summary Delete identity
     * @param {UsersApiDeleteIdentityByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteIdentityById(requestParameters: UsersApiDeleteIdentityByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteIdentityById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user sessions by its unique ID.
     * @summary Delete user session
     * @param {UsersApiDeleteSessionByUserIdAndSessionIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteSessionByUserIdAndSessionId(requestParameters: UsersApiDeleteSessionByUserIdAndSessionIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteSessionByUserIdAndSessionId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all user\'s sessions by using the user\'s unique ID.
     * @summary Delete user sessions
     * @param {UsersApiDeleteSessionsByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteSessionsById(requestParameters: UsersApiDeleteSessionsByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteSessionsById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a messaging target.
     * @summary Delete user target
     * @param {UsersApiDeleteTargetMessagingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteTargetMessaging(requestParameters: UsersApiDeleteTargetMessagingRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteTargetMessaging(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a token with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [PUT /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession) endpoint to complete the login process.
     * @summary Create token
     * @param {UsersApiGenerateTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public generateToken(requestParameters: UsersApiGenerateTokenRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).generateToken(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user activity logs list by its unique ID.
     * @summary List user logs
     * @param {UsersApiGetLogsByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getLogsByUserId(requestParameters: UsersApiGetLogsByUserIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getLogsByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user membership list by its unique ID.
     * @summary List user memberships
     * @param {UsersApiGetMembershipsByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getMembershipsById(requestParameters: UsersApiGetMembershipsByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMembershipsById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
     * @summary Get MFA Recovery Codes
     * @param {UsersApiGetMfaRecoveryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getMfaRecoveryCodes(requestParameters: UsersApiGetMfaRecoveryCodesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMfaRecoveryCodes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user\'s push notification target by ID.
     * @summary Get User Target
     * @param {UsersApiGetTargetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getTarget(requestParameters: UsersApiGetTargetRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getTarget(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get users usage stats
     * @param {UsersApiGetUsageStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUsageStats(requestParameters: UsersApiGetUsageStatsRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsageStats(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user by its unique ID.
     * @summary Get user
     * @param {UsersApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUserById(requestParameters: UsersApiGetUserByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user preferences by its unique ID.
     * @summary Get user preferences
     * @param {UsersApiGetUserPrefsByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUserPrefsById(requestParameters: UsersApiGetUserPrefsByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserPrefsById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all the project\'s users. You can use the query params to filter your results.
     * @summary List users
     * @param {UsersApiListFilteredUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listFilteredUsers(requestParameters: UsersApiListFilteredUsersRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listFilteredUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get identities for all users.
     * @summary List Identities
     * @param {UsersApiListIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listIdentities(requestParameters: UsersApiListIdentitiesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listIdentities(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the factors available on the account to be used as a MFA challange.
     * @summary List Factors
     * @param {UsersApiListMfaFactorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listMfaFactors(requestParameters: UsersApiListMfaFactorsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listMfaFactors(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user sessions list by its unique ID.
     * @summary List user sessions
     * @param {UsersApiListSessionsByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listSessionsByUserId(requestParameters: UsersApiListSessionsByUserIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listSessionsByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the messaging targets that are associated with a user.
     * @summary List User Targets
     * @param {UsersApiListTargetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listTargets(requestParameters: UsersApiListTargetsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listTargets(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
     * @summary Regenerate MFA Recovery Codes
     * @param {UsersApiRegenerateMfaRecoveryCodesByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public regenerateMfaRecoveryCodesByUserId(requestParameters: UsersApiRegenerateMfaRecoveryCodesByUserIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).regenerateMfaRecoveryCodesByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user email by its unique ID.
     * @summary Update email
     * @param {UsersApiUpdateEmailByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateEmailById(requestParameters: UsersApiUpdateEmailByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateEmailById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user email verification status by its unique ID.
     * @summary Update email verification
     * @param {UsersApiUpdateEmailVerificationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateEmailVerificationStatus(requestParameters: UsersApiUpdateEmailVerificationStatusRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateEmailVerificationStatus(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user labels by its unique ID.   Labels can be used to grant access to resources. While teams are a way for user\'s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appwrite.io/docs/permissions) for more info.
     * @summary Update user labels
     * @param {UsersApiUpdateLabelsByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateLabelsByUserId(requestParameters: UsersApiUpdateLabelsByUserIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateLabelsByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a messaging target.
     * @summary Update User target
     * @param {UsersApiUpdateMessagingTargetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateMessagingTarget(requestParameters: UsersApiUpdateMessagingTargetRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateMessagingTarget(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable or disable MFA on a user account.
     * @summary Update MFA
     * @param {UsersApiUpdateMfaStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateMfaStatus(requestParameters: UsersApiUpdateMfaStatusRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateMfaStatus(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user name by its unique ID.
     * @summary Update name
     * @param {UsersApiUpdateNameByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateNameById(requestParameters: UsersApiUpdateNameByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateNameById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user password by its unique ID.
     * @summary Update password
     * @param {UsersApiUpdatePasswordByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updatePasswordByUserId(requestParameters: UsersApiUpdatePasswordByUserIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updatePasswordByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user phone by its unique ID.
     * @summary Update phone
     * @param {UsersApiUpdatePhoneByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updatePhoneByUserId(requestParameters: UsersApiUpdatePhoneByUserIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updatePhoneByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user phone verification status by its unique ID.
     * @summary Update phone verification
     * @param {UsersApiUpdatePhoneVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updatePhoneVerification(requestParameters: UsersApiUpdatePhoneVerificationRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updatePhoneVerification(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
     * @summary Update user preferences
     * @param {UsersApiUpdatePrefsByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updatePrefsById(requestParameters: UsersApiUpdatePrefsByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updatePrefsById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user\'s ID reserved.
     * @summary Update user status
     * @param {UsersApiUpdateStatusByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateStatusByUserId(requestParameters: UsersApiUpdateStatusByUserIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateStatusByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
