/* tslint:disable */
/* eslint-disable */
/*
Appwrite

Appwrite backend as a service cuts up to 70% of the time and costs required for building a modern application. We abstract and simplify common development tasks behind a REST APIs, to help you develop your app in a fast and secure way. For full API documentation and tutorials go to [https://appwrite.io/docs](https://appwrite.io/docs)

The version of the OpenAPI document: 1.5.0
Contact: team@appwrite.io

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { HealthAntivirus } from '../models';
// @ts-ignore
import { HealthCertificate } from '../models';
// @ts-ignore
import { HealthQueue } from '../models';
// @ts-ignore
import { HealthStatus } from '../models';
// @ts-ignore
import { HealthTime } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue server.
         * @summary Get certificates queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        certificatesQueueCount: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/certificates',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite HTTP server is up and responsive.
         * @summary Get HTTP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAppwriteHttpServer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite Antivirus server is up and connection is successful.
         * @summary Get antivirus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAvStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/anti-virus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/anti-virus',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite in-memory cache servers are up and connection is successful.
         * @summary Get cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCacheStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/cache`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/cache',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite database servers are up and connection is successful.
         * @summary Get DB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDatabaseStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/db`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/db',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite local storage device is up and connection is successful.
         * @summary Get local storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkLocalStorage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/storage/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/storage/local',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite queue messaging servers are up and connection is successful.
         * @summary Get queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkQueueStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite storage device is up and connection is successful.
         * @summary Get storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkStorageDevice: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/storage',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of function executions that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get functions queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsQueueCount: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/functions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/functions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of builds that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get builds queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildsQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/builds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/builds',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of database changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get databases queue
         * @param {string} [name] Queue name for which to check the queue size
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabasesQueue: async (name?: string, threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/databases',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the amount of failed jobs in a given queue. 
         * @summary Get number of failed queue jobs
         * @param {'v1-database' | 'v1-deletes' | 'v1-audits' | 'v1-mails' | 'v1-functions' | 'v1-usage' | 'v1-usage-dump' | 'webhooksv1' | 'v1-certificates' | 'v1-builds' | 'v1-messaging' | 'v1-migrations' | 'hamsterv1'} name The name of the queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailedJobs: async (name: 'v1-database' | 'v1-deletes' | 'v1-audits' | 'v1-mails' | 'v1-functions' | 'v1-usage' | 'v1-usage-dump' | 'webhooksv1' | 'v1-certificates' | 'v1-builds' | 'v1-messaging' | 'v1-migrations' | 'hamsterv1', threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getFailedJobs', 'name', name)
            const localVarPath = `/health/queue/failed/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name !== undefined ? name : `-name-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/failed/{name}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of mails that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get mails queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailsQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/mails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/mails',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of messages that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get messaging queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagingQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/messaging`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/messaging',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of migrations that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get migrations queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrationsQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/migrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/migrations',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of background destructive changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get deletes queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueDeletes: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/deletes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/deletes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of logs that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get logs queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueLogs: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/logs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueUsageMetrics: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/usage',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the SSL certificate for a domain
         * @summary Get the SSL certificate for a domain
         * @param {string} [domain] string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSslCertificate: async (domain?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/certificate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/certificate',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of projects containing metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage dump queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageDumpQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/usage-dump`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/usage-dump',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite pub-sub servers are up and connection is successful.
         * @summary Get pubsub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubsubGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/pubsub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/pubsub',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
         * @summary Get time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncTimeWithNtp: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/time',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of webhooks that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get webhooks queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksQueueCount: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/webhooks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue server.
         * @summary Get certificates queue
         * @param {HealthApiCertificatesQueueCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async certificatesQueueCount(requestParameters: HealthApiCertificatesQueueCountRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.certificatesQueueCount(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite HTTP server is up and responsive.
         * @summary Get HTTP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAppwriteHttpServer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAppwriteHttpServer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite Antivirus server is up and connection is successful.
         * @summary Get antivirus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAvStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthAntivirus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAvStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite in-memory cache servers are up and connection is successful.
         * @summary Get cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkCacheStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkCacheStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite database servers are up and connection is successful.
         * @summary Get DB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDatabaseStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDatabaseStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite local storage device is up and connection is successful.
         * @summary Get local storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkLocalStorage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkLocalStorage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite queue messaging servers are up and connection is successful.
         * @summary Get queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkQueueStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkQueueStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite storage device is up and connection is successful.
         * @summary Get storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkStorageDevice(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkStorageDevice(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of function executions that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get functions queue
         * @param {HealthApiFunctionsQueueCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsQueueCount(requestParameters: HealthApiFunctionsQueueCountRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsQueueCount(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of builds that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get builds queue
         * @param {HealthApiGetBuildsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuildsQueue(requestParameters: HealthApiGetBuildsQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildsQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of database changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get databases queue
         * @param {HealthApiGetDatabasesQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabasesQueue(requestParameters: HealthApiGetDatabasesQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabasesQueue(requestParameters.name, requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the amount of failed jobs in a given queue. 
         * @summary Get number of failed queue jobs
         * @param {HealthApiGetFailedJobsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFailedJobs(requestParameters: HealthApiGetFailedJobsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFailedJobs(requestParameters.name, requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of mails that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get mails queue
         * @param {HealthApiGetMailsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMailsQueue(requestParameters: HealthApiGetMailsQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailsQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of messages that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get messaging queue
         * @param {HealthApiGetMessagingQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagingQueue(requestParameters: HealthApiGetMessagingQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagingQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of migrations that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get migrations queue
         * @param {HealthApiGetMigrationsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMigrationsQueue(requestParameters: HealthApiGetMigrationsQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMigrationsQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of background destructive changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get deletes queue
         * @param {HealthApiGetQueueDeletesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueDeletes(requestParameters: HealthApiGetQueueDeletesRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueDeletes(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of logs that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get logs queue
         * @param {HealthApiGetQueueLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueLogs(requestParameters: HealthApiGetQueueLogsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueLogs(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage queue
         * @param {HealthApiGetQueueUsageMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueUsageMetrics(requestParameters: HealthApiGetQueueUsageMetricsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueUsageMetrics(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the SSL certificate for a domain
         * @summary Get the SSL certificate for a domain
         * @param {HealthApiGetSslCertificateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSslCertificate(requestParameters: HealthApiGetSslCertificateRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCertificate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSslCertificate(requestParameters.domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of projects containing metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage dump queue
         * @param {HealthApiGetUsageDumpQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageDumpQueue(requestParameters: HealthApiGetUsageDumpQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageDumpQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite pub-sub servers are up and connection is successful.
         * @summary Get pubsub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pubsubGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pubsubGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
         * @summary Get time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncTimeWithNtp(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncTimeWithNtp(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of webhooks that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get webhooks queue
         * @param {HealthApiWebhooksQueueCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksQueueCount(requestParameters: HealthApiWebhooksQueueCountRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksQueueCount(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue server.
         * @summary Get certificates queue
         * @param {HealthApiCertificatesQueueCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        certificatesQueueCount(requestParameters: HealthApiCertificatesQueueCountRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.certificatesQueueCount(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite HTTP server is up and responsive.
         * @summary Get HTTP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAppwriteHttpServer(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkAppwriteHttpServer(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite Antivirus server is up and connection is successful.
         * @summary Get antivirus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAvStatus(options?: AxiosRequestConfig): AxiosPromise<HealthAntivirus> {
            return localVarFp.checkAvStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite in-memory cache servers are up and connection is successful.
         * @summary Get cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCacheStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkCacheStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite database servers are up and connection is successful.
         * @summary Get DB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDatabaseStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkDatabaseStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite local storage device is up and connection is successful.
         * @summary Get local storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkLocalStorage(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkLocalStorage(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite queue messaging servers are up and connection is successful.
         * @summary Get queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkQueueStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkQueueStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite storage device is up and connection is successful.
         * @summary Get storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkStorageDevice(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkStorageDevice(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of function executions that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get functions queue
         * @param {HealthApiFunctionsQueueCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsQueueCount(requestParameters: HealthApiFunctionsQueueCountRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.functionsQueueCount(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of builds that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get builds queue
         * @param {HealthApiGetBuildsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildsQueue(requestParameters: HealthApiGetBuildsQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getBuildsQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of database changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get databases queue
         * @param {HealthApiGetDatabasesQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabasesQueue(requestParameters: HealthApiGetDatabasesQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getDatabasesQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the amount of failed jobs in a given queue. 
         * @summary Get number of failed queue jobs
         * @param {HealthApiGetFailedJobsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailedJobs(requestParameters: HealthApiGetFailedJobsRequest, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getFailedJobs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of mails that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get mails queue
         * @param {HealthApiGetMailsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailsQueue(requestParameters: HealthApiGetMailsQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getMailsQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of messages that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get messaging queue
         * @param {HealthApiGetMessagingQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagingQueue(requestParameters: HealthApiGetMessagingQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getMessagingQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of migrations that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get migrations queue
         * @param {HealthApiGetMigrationsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrationsQueue(requestParameters: HealthApiGetMigrationsQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getMigrationsQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of background destructive changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get deletes queue
         * @param {HealthApiGetQueueDeletesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueDeletes(requestParameters: HealthApiGetQueueDeletesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getQueueDeletes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of logs that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get logs queue
         * @param {HealthApiGetQueueLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueLogs(requestParameters: HealthApiGetQueueLogsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getQueueLogs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage queue
         * @param {HealthApiGetQueueUsageMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueUsageMetrics(requestParameters: HealthApiGetQueueUsageMetricsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getQueueUsageMetrics(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the SSL certificate for a domain
         * @summary Get the SSL certificate for a domain
         * @param {HealthApiGetSslCertificateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSslCertificate(requestParameters: HealthApiGetSslCertificateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthCertificate> {
            return localVarFp.getSslCertificate(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of projects containing metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage dump queue
         * @param {HealthApiGetUsageDumpQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageDumpQueue(requestParameters: HealthApiGetUsageDumpQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getUsageDumpQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite pub-sub servers are up and connection is successful.
         * @summary Get pubsub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubsubGet(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.pubsubGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
         * @summary Get time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncTimeWithNtp(options?: AxiosRequestConfig): AxiosPromise<HealthTime> {
            return localVarFp.syncTimeWithNtp(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of webhooks that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get webhooks queue
         * @param {HealthApiWebhooksQueueCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksQueueCount(requestParameters: HealthApiWebhooksQueueCountRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.webhooksQueueCount(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for certificatesQueueCount operation in HealthApi.
 * @export
 * @interface HealthApiCertificatesQueueCountRequest
 */
export type HealthApiCertificatesQueueCountRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiCertificatesQueueCount
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for functionsQueueCount operation in HealthApi.
 * @export
 * @interface HealthApiFunctionsQueueCountRequest
 */
export type HealthApiFunctionsQueueCountRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiFunctionsQueueCount
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getBuildsQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetBuildsQueueRequest
 */
export type HealthApiGetBuildsQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetBuildsQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getDatabasesQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetDatabasesQueueRequest
 */
export type HealthApiGetDatabasesQueueRequest = {
    
    /**
    * Queue name for which to check the queue size
    * @type {string}
    * @memberof HealthApiGetDatabasesQueue
    */
    readonly name?: string
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetDatabasesQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getFailedJobs operation in HealthApi.
 * @export
 * @interface HealthApiGetFailedJobsRequest
 */
export type HealthApiGetFailedJobsRequest = {
    
    /**
    * The name of the queue
    * @type {'v1-database' | 'v1-deletes' | 'v1-audits' | 'v1-mails' | 'v1-functions' | 'v1-usage' | 'v1-usage-dump' | 'webhooksv1' | 'v1-certificates' | 'v1-builds' | 'v1-messaging' | 'v1-migrations' | 'hamsterv1'}
    * @memberof HealthApiGetFailedJobs
    */
    readonly name: 'v1-database' | 'v1-deletes' | 'v1-audits' | 'v1-mails' | 'v1-functions' | 'v1-usage' | 'v1-usage-dump' | 'webhooksv1' | 'v1-certificates' | 'v1-builds' | 'v1-messaging' | 'v1-migrations' | 'hamsterv1'
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetFailedJobs
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getMailsQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetMailsQueueRequest
 */
export type HealthApiGetMailsQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetMailsQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getMessagingQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetMessagingQueueRequest
 */
export type HealthApiGetMessagingQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetMessagingQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getMigrationsQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetMigrationsQueueRequest
 */
export type HealthApiGetMigrationsQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetMigrationsQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getQueueDeletes operation in HealthApi.
 * @export
 * @interface HealthApiGetQueueDeletesRequest
 */
export type HealthApiGetQueueDeletesRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetQueueDeletes
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getQueueLogs operation in HealthApi.
 * @export
 * @interface HealthApiGetQueueLogsRequest
 */
export type HealthApiGetQueueLogsRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetQueueLogs
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getQueueUsageMetrics operation in HealthApi.
 * @export
 * @interface HealthApiGetQueueUsageMetricsRequest
 */
export type HealthApiGetQueueUsageMetricsRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetQueueUsageMetrics
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getSslCertificate operation in HealthApi.
 * @export
 * @interface HealthApiGetSslCertificateRequest
 */
export type HealthApiGetSslCertificateRequest = {
    
    /**
    * string
    * @type {string}
    * @memberof HealthApiGetSslCertificate
    */
    readonly domain?: string
    
}

/**
 * Request parameters for getUsageDumpQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetUsageDumpQueueRequest
 */
export type HealthApiGetUsageDumpQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetUsageDumpQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for webhooksQueueCount operation in HealthApi.
 * @export
 * @interface HealthApiWebhooksQueueCountRequest
 */
export type HealthApiWebhooksQueueCountRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiWebhooksQueueCount
    */
    readonly threshold?: number
    
}

/**
 * HealthApiGenerated - object-oriented interface
 * @export
 * @class HealthApiGenerated
 * @extends {BaseAPI}
 */
export class HealthApiGenerated extends BaseAPI {
    /**
     * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue server.
     * @summary Get certificates queue
     * @param {HealthApiCertificatesQueueCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public certificatesQueueCount(requestParameters: HealthApiCertificatesQueueCountRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).certificatesQueueCount(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite HTTP server is up and responsive.
     * @summary Get HTTP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkAppwriteHttpServer(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkAppwriteHttpServer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite Antivirus server is up and connection is successful.
     * @summary Get antivirus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkAvStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkAvStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite in-memory cache servers are up and connection is successful.
     * @summary Get cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkCacheStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkCacheStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite database servers are up and connection is successful.
     * @summary Get DB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkDatabaseStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkDatabaseStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite local storage device is up and connection is successful.
     * @summary Get local storage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkLocalStorage(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkLocalStorage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite queue messaging servers are up and connection is successful.
     * @summary Get queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkQueueStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkQueueStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite storage device is up and connection is successful.
     * @summary Get storage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkStorageDevice(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkStorageDevice(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of function executions that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get functions queue
     * @param {HealthApiFunctionsQueueCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public functionsQueueCount(requestParameters: HealthApiFunctionsQueueCountRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).functionsQueueCount(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of builds that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get builds queue
     * @param {HealthApiGetBuildsQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getBuildsQueue(requestParameters: HealthApiGetBuildsQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getBuildsQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of database changes that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get databases queue
     * @param {HealthApiGetDatabasesQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getDatabasesQueue(requestParameters: HealthApiGetDatabasesQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getDatabasesQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the amount of failed jobs in a given queue. 
     * @summary Get number of failed queue jobs
     * @param {HealthApiGetFailedJobsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getFailedJobs(requestParameters: HealthApiGetFailedJobsRequest, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getFailedJobs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of mails that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get mails queue
     * @param {HealthApiGetMailsQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getMailsQueue(requestParameters: HealthApiGetMailsQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getMailsQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of messages that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get messaging queue
     * @param {HealthApiGetMessagingQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getMessagingQueue(requestParameters: HealthApiGetMessagingQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getMessagingQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of migrations that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get migrations queue
     * @param {HealthApiGetMigrationsQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getMigrationsQueue(requestParameters: HealthApiGetMigrationsQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getMigrationsQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of background destructive changes that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get deletes queue
     * @param {HealthApiGetQueueDeletesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getQueueDeletes(requestParameters: HealthApiGetQueueDeletesRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getQueueDeletes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of logs that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get logs queue
     * @param {HealthApiGetQueueLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getQueueLogs(requestParameters: HealthApiGetQueueLogsRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getQueueLogs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of metrics that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get usage queue
     * @param {HealthApiGetQueueUsageMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getQueueUsageMetrics(requestParameters: HealthApiGetQueueUsageMetricsRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getQueueUsageMetrics(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the SSL certificate for a domain
     * @summary Get the SSL certificate for a domain
     * @param {HealthApiGetSslCertificateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getSslCertificate(requestParameters: HealthApiGetSslCertificateRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getSslCertificate(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of projects containing metrics that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get usage dump queue
     * @param {HealthApiGetUsageDumpQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getUsageDumpQueue(requestParameters: HealthApiGetUsageDumpQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getUsageDumpQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite pub-sub servers are up and connection is successful.
     * @summary Get pubsub
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public pubsubGet(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).pubsubGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
     * @summary Get time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public syncTimeWithNtp(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).syncTimeWithNtp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of webhooks that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get webhooks queue
     * @param {HealthApiWebhooksQueueCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public webhooksQueueCount(requestParameters: HealthApiWebhooksQueueCountRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).webhooksQueueCount(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
