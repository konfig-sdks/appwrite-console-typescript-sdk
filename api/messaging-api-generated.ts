/* tslint:disable */
/* eslint-disable */
/*
Appwrite

Appwrite backend as a service cuts up to 70% of the time and costs required for building a modern application. We abstract and simplify common development tasks behind a REST APIs, to help you develop your app in a fast and secure way. For full API documentation and tutorials go to [https://appwrite.io/docs](https://appwrite.io/docs)

The version of the OpenAPI document: 1.5.0
Contact: team@appwrite.io

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { LogList } from '../models';
// @ts-ignore
import { Message } from '../models';
// @ts-ignore
import { MessageList } from '../models';
// @ts-ignore
import { MessagingCreateApnsProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateEmailMessageRequest } from '../models';
// @ts-ignore
import { MessagingCreateFcmProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateMailgunProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateMsgProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateNewTopicRequest } from '../models';
// @ts-ignore
import { MessagingCreatePushNotificationRequest } from '../models';
// @ts-ignore
import { MessagingCreateSendgridProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateSmsMessageRequest } from '../models';
// @ts-ignore
import { MessagingCreateSmtpProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateSubscriberRequest } from '../models';
// @ts-ignore
import { MessagingCreateTelesignProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateTextmagicProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateTwilioProviderRequest } from '../models';
// @ts-ignore
import { MessagingCreateVonageProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateApnsProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateEmailByIdRequest } from '../models';
// @ts-ignore
import { MessagingUpdateFcmProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateMailgunProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateProviderByIdRequest } from '../models';
// @ts-ignore
import { MessagingUpdatePushMessageRequest } from '../models';
// @ts-ignore
import { MessagingUpdateSendgridProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateSmsMessageByIdRequest } from '../models';
// @ts-ignore
import { MessagingUpdateSmtpProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateTelesignProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateTextmagicProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateTopicByIdRequest } from '../models';
// @ts-ignore
import { MessagingUpdateTwilioProviderRequest } from '../models';
// @ts-ignore
import { MessagingUpdateVonageProviderByIdRequest } from '../models';
// @ts-ignore
import { Provider } from '../models';
// @ts-ignore
import { ProviderList } from '../models';
// @ts-ignore
import { Subscriber } from '../models';
// @ts-ignore
import { SubscriberList } from '../models';
// @ts-ignore
import { TargetList } from '../models';
// @ts-ignore
import { Topic } from '../models';
// @ts-ignore
import { TopicList } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * MessagingApi - axios parameter creator
 * @export
 */
export const MessagingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Apple Push Notification service provider.
         * @summary Create APNS provider
         * @param {MessagingCreateApnsProviderRequest} [messagingCreateApnsProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApnsProvider: async (messagingCreateApnsProviderRequest?: MessagingCreateApnsProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/apns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateApnsProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/apns',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateApnsProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new email message.
         * @summary Create email
         * @param {MessagingCreateEmailMessageRequest} [messagingCreateEmailMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailMessage: async (messagingCreateEmailMessageRequest?: MessagingCreateEmailMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/messages/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateEmailMessageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/email',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateEmailMessageRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Firebase Cloud Messaging provider.
         * @summary Create FCM provider
         * @param {MessagingCreateFcmProviderRequest} [messagingCreateFcmProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFcmProvider: async (messagingCreateFcmProviderRequest?: MessagingCreateFcmProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/fcm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateFcmProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/fcm',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateFcmProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Mailgun provider.
         * @summary Create Mailgun provider
         * @param {MessagingCreateMailgunProviderRequest} [messagingCreateMailgunProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMailgunProvider: async (messagingCreateMailgunProviderRequest?: MessagingCreateMailgunProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/mailgun`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateMailgunProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/mailgun',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateMailgunProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new MSG91 provider.
         * @summary Create Msg91 provider
         * @param {MessagingCreateMsgProviderRequest} [messagingCreateMsgProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMsgProvider: async (messagingCreateMsgProviderRequest?: MessagingCreateMsgProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/msg91`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateMsgProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/msg91',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateMsgProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new topic.
         * @summary Create topic
         * @param {MessagingCreateNewTopicRequest} [messagingCreateNewTopicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTopic: async (messagingCreateNewTopicRequest?: MessagingCreateNewTopicRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateNewTopicRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateNewTopicRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new push notification.
         * @summary Create push notification
         * @param {MessagingCreatePushNotificationRequest} [messagingCreatePushNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPushNotification: async (messagingCreatePushNotificationRequest?: MessagingCreatePushNotificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/messages/push`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreatePushNotificationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/push',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreatePushNotificationRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Sendgrid provider.
         * @summary Create Sendgrid provider
         * @param {MessagingCreateSendgridProviderRequest} [messagingCreateSendgridProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSendgridProvider: async (messagingCreateSendgridProviderRequest?: MessagingCreateSendgridProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/sendgrid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateSendgridProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/sendgrid',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateSendgridProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new SMS message.
         * @summary Create SMS
         * @param {MessagingCreateSmsMessageRequest} [messagingCreateSmsMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSmsMessage: async (messagingCreateSmsMessageRequest?: MessagingCreateSmsMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/messages/sms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateSmsMessageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/sms',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateSmsMessageRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new SMTP provider.
         * @summary Create SMTP provider
         * @param {MessagingCreateSmtpProviderRequest} [messagingCreateSmtpProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSmtpProvider: async (messagingCreateSmtpProviderRequest?: MessagingCreateSmtpProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/smtp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateSmtpProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/smtp',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateSmtpProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new subscriber.
         * @summary Create subscriber
         * @param {string} topicId Topic ID. The topic ID to subscribe to.
         * @param {MessagingCreateSubscriberRequest} [messagingCreateSubscriberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriber: async (topicId: string, messagingCreateSubscriberRequest?: MessagingCreateSubscriberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('createSubscriber', 'topicId', topicId)
            const localVarPath = `/messaging/topics/{topicId}/subscribers`
                .replace(`{${"topicId"}}`, encodeURIComponent(String(topicId !== undefined ? topicId : `-topicId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-JWT", keyParamName: "jWT", configuration })
            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateSubscriberRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics/{topicId}/subscribers',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateSubscriberRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Telesign provider.
         * @summary Create Telesign provider
         * @param {MessagingCreateTelesignProviderRequest} [messagingCreateTelesignProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTelesignProvider: async (messagingCreateTelesignProviderRequest?: MessagingCreateTelesignProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/telesign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateTelesignProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/telesign',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateTelesignProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Textmagic provider.
         * @summary Create Textmagic provider
         * @param {MessagingCreateTextmagicProviderRequest} [messagingCreateTextmagicProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextmagicProvider: async (messagingCreateTextmagicProviderRequest?: MessagingCreateTextmagicProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/textmagic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateTextmagicProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/textmagic',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateTextmagicProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Twilio provider.
         * @summary Create Twilio provider
         * @param {MessagingCreateTwilioProviderRequest} [messagingCreateTwilioProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwilioProvider: async (messagingCreateTwilioProviderRequest?: MessagingCreateTwilioProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/twilio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateTwilioProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/twilio',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateTwilioProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Vonage provider.
         * @summary Create Vonage provider
         * @param {MessagingCreateVonageProviderRequest} [messagingCreateVonageProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVonageProvider: async (messagingCreateVonageProviderRequest?: MessagingCreateVonageProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers/vonage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingCreateVonageProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/vonage',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingCreateVonageProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a message. If the message is not a draft or scheduled, but has been sent, this will not recall the message.
         * @summary Delete message
         * @param {string} messageId Message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (messageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            const localVarPath = `/messaging/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-messageId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/{messageId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a provider by its unique ID.
         * @summary Delete provider
         * @param {string} providerId Provider ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProviderById: async (providerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('deleteProviderById', 'providerId', providerId)
            const localVarPath = `/messaging/providers/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/{providerId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a subscriber by its unique ID.
         * @summary Delete subscriber
         * @param {string} topicId Topic ID. The topic ID subscribed to.
         * @param {string} subscriberId Subscriber ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriberById: async (topicId: string, subscriberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('deleteSubscriberById', 'topicId', topicId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('deleteSubscriberById', 'subscriberId', subscriberId)
            const localVarPath = `/messaging/topics/{topicId}/subscribers/{subscriberId}`
                .replace(`{${"topicId"}}`, encodeURIComponent(String(topicId !== undefined ? topicId : `-topicId-`)))
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId !== undefined ? subscriberId : `-subscriberId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-JWT", keyParamName: "jWT", configuration })
            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics/{topicId}/subscribers/{subscriberId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a topic by its unique ID.
         * @summary Delete topic
         * @param {string} topicId Topic ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopicById: async (topicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('deleteTopicById', 'topicId', topicId)
            const localVarPath = `/messaging/topics/{topicId}`
                .replace(`{${"topicId"}}`, encodeURIComponent(String(topicId !== undefined ? topicId : `-topicId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics/{topicId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a message by its unique ID. 
         * @summary Get message
         * @param {string} messageId Message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById: async (messageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessageById', 'messageId', messageId)
            const localVarPath = `/messaging/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-messageId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/{messageId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a provider by its unique ID. 
         * @summary Get provider
         * @param {string} providerId Provider ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderById: async (providerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('getProviderById', 'providerId', providerId)
            const localVarPath = `/messaging/providers/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/{providerId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a subscriber by its unique ID. 
         * @summary Get subscriber
         * @param {string} topicId Topic ID. The topic ID subscribed to.
         * @param {string} subscriberId Subscriber ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriberById: async (topicId: string, subscriberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getSubscriberById', 'topicId', topicId)
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('getSubscriberById', 'subscriberId', subscriberId)
            const localVarPath = `/messaging/topics/{topicId}/subscribers/{subscriberId}`
                .replace(`{${"topicId"}}`, encodeURIComponent(String(topicId !== undefined ? topicId : `-topicId-`)))
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId !== undefined ? subscriberId : `-subscriberId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics/{topicId}/subscribers/{subscriberId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a topic by its unique ID. 
         * @summary Get topic
         * @param {string} topicId Topic ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicById: async (topicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicById', 'topicId', topicId)
            const localVarPath = `/messaging/topics/{topicId}`
                .replace(`{${"topicId"}}`, encodeURIComponent(String(topicId !== undefined ? topicId : `-topicId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics/{topicId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all messages from the current Appwrite project.
         * @summary List messages
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: scheduledAt, deliveredAt, deliveredTotal, status, description, providerType
         * @param {string} [search] Search term to filter your list results. Max length: 256 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllMessages: async (queries?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the message activity logs listed by its unique ID.
         * @summary List message logs
         * @param {string} messageId Message ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessageLogs: async (messageId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('listMessageLogs', 'messageId', messageId)
            const localVarPath = `/messaging/messages/{messageId}/logs`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-messageId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/{messageId}/logs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the provider activity logs listed by its unique ID.
         * @summary List provider logs
         * @param {string} providerId Provider ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviderLogs: async (providerId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('listProviderLogs', 'providerId', providerId)
            const localVarPath = `/messaging/providers/{providerId}/logs`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/{providerId}/logs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all providers from the current Appwrite project.
         * @summary List providers
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, provider, type, enabled
         * @param {string} [search] Search term to filter your list results. Max length: 256 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviders: async (queries?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscriber activity logs listed by its unique ID.
         * @summary List subscriber logs
         * @param {string} subscriberId Subscriber ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriberLogs: async (subscriberId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriberId' is not null or undefined
            assertParamExists('listSubscriberLogs', 'subscriberId', subscriberId)
            const localVarPath = `/messaging/subscribers/{subscriberId}/logs`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId !== undefined ? subscriberId : `-subscriberId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/subscribers/{subscriberId}/logs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all subscribers from the current Appwrite project.
         * @summary List subscribers
         * @param {string} topicId Topic ID. The topic ID subscribed to.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, provider, type, enabled
         * @param {string} [search] Search term to filter your list results. Max length: 256 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscribers: async (topicId: string, queries?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('listSubscribers', 'topicId', topicId)
            const localVarPath = `/messaging/topics/{topicId}/subscribers`
                .replace(`{${"topicId"}}`, encodeURIComponent(String(topicId !== undefined ? topicId : `-topicId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics/{topicId}/subscribers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the targets associated with a message.
         * @summary List message targets
         * @param {string} messageId Message ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: userId, providerId, identifier, providerType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTargets: async (messageId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('listTargets', 'messageId', messageId)
            const localVarPath = `/messaging/messages/{messageId}/targets`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-messageId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/{messageId}/targets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the topic activity logs listed by its unique ID.
         * @summary List topic logs
         * @param {string} topicId Topic ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopicLogs: async (topicId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('listTopicLogs', 'topicId', topicId)
            const localVarPath = `/messaging/topics/{topicId}/logs`
                .replace(`{${"topicId"}}`, encodeURIComponent(String(topicId !== undefined ? topicId : `-topicId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics/{topicId}/logs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all topics from the current Appwrite project.
         * @summary List topics
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, description, emailTotal, smsTotal, pushTotal
         * @param {string} [search] Search term to filter your list results. Max length: 256 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopics: async (queries?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messaging/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Apple Push Notification service provider by its unique ID.
         * @summary Update APNS provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateApnsProviderRequest} [messagingUpdateApnsProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApnsProvider: async (providerId: string, messagingUpdateApnsProviderRequest?: MessagingUpdateApnsProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateApnsProvider', 'providerId', providerId)
            const localVarPath = `/messaging/providers/apns/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateApnsProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/apns/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateApnsProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an email message by its unique ID. 
         * @summary Update email
         * @param {string} messageId Message ID.
         * @param {MessagingUpdateEmailByIdRequest} [messagingUpdateEmailByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailById: async (messageId: string, messagingUpdateEmailByIdRequest?: MessagingUpdateEmailByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('updateEmailById', 'messageId', messageId)
            const localVarPath = `/messaging/messages/email/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-messageId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateEmailByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/email/{messageId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateEmailByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Firebase Cloud Messaging provider by its unique ID.
         * @summary Update FCM provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateFcmProviderRequest} [messagingUpdateFcmProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFcmProvider: async (providerId: string, messagingUpdateFcmProviderRequest?: MessagingUpdateFcmProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateFcmProvider', 'providerId', providerId)
            const localVarPath = `/messaging/providers/fcm/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateFcmProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/fcm/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateFcmProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Mailgun provider by its unique ID.
         * @summary Update Mailgun provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateMailgunProviderRequest} [messagingUpdateMailgunProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMailgunProvider: async (providerId: string, messagingUpdateMailgunProviderRequest?: MessagingUpdateMailgunProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateMailgunProvider', 'providerId', providerId)
            const localVarPath = `/messaging/providers/mailgun/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateMailgunProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/mailgun/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateMailgunProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a MSG91 provider by its unique ID.
         * @summary Update Msg91 provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateProviderByIdRequest} [messagingUpdateProviderByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProviderById: async (providerId: string, messagingUpdateProviderByIdRequest?: MessagingUpdateProviderByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateProviderById', 'providerId', providerId)
            const localVarPath = `/messaging/providers/msg91/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateProviderByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/msg91/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateProviderByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a push notification by its unique ID. 
         * @summary Update push notification
         * @param {string} messageId Message ID.
         * @param {MessagingUpdatePushMessageRequest} [messagingUpdatePushMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePushMessage: async (messageId: string, messagingUpdatePushMessageRequest?: MessagingUpdatePushMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('updatePushMessage', 'messageId', messageId)
            const localVarPath = `/messaging/messages/push/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-messageId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdatePushMessageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/push/{messageId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdatePushMessageRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Sendgrid provider by its unique ID.
         * @summary Update Sendgrid provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateSendgridProviderRequest} [messagingUpdateSendgridProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSendgridProvider: async (providerId: string, messagingUpdateSendgridProviderRequest?: MessagingUpdateSendgridProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateSendgridProvider', 'providerId', providerId)
            const localVarPath = `/messaging/providers/sendgrid/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateSendgridProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/sendgrid/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateSendgridProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an email message by its unique ID. 
         * @summary Update SMS
         * @param {string} messageId Message ID.
         * @param {MessagingUpdateSmsMessageByIdRequest} [messagingUpdateSmsMessageByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSmsMessageById: async (messageId: string, messagingUpdateSmsMessageByIdRequest?: MessagingUpdateSmsMessageByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('updateSmsMessageById', 'messageId', messageId)
            const localVarPath = `/messaging/messages/sms/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-messageId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateSmsMessageByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/messages/sms/{messageId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateSmsMessageByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a SMTP provider by its unique ID.
         * @summary Update SMTP provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateSmtpProviderRequest} [messagingUpdateSmtpProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSmtpProvider: async (providerId: string, messagingUpdateSmtpProviderRequest?: MessagingUpdateSmtpProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateSmtpProvider', 'providerId', providerId)
            const localVarPath = `/messaging/providers/smtp/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateSmtpProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/smtp/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateSmtpProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Telesign provider by its unique ID.
         * @summary Update Telesign provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateTelesignProviderRequest} [messagingUpdateTelesignProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTelesignProvider: async (providerId: string, messagingUpdateTelesignProviderRequest?: MessagingUpdateTelesignProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateTelesignProvider', 'providerId', providerId)
            const localVarPath = `/messaging/providers/telesign/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateTelesignProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/telesign/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateTelesignProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Textmagic provider by its unique ID.
         * @summary Update Textmagic provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateTextmagicProviderRequest} [messagingUpdateTextmagicProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextmagicProvider: async (providerId: string, messagingUpdateTextmagicProviderRequest?: MessagingUpdateTextmagicProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateTextmagicProvider', 'providerId', providerId)
            const localVarPath = `/messaging/providers/textmagic/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateTextmagicProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/textmagic/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateTextmagicProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a topic by its unique ID. 
         * @summary Update topic
         * @param {string} topicId Topic ID.
         * @param {MessagingUpdateTopicByIdRequest} [messagingUpdateTopicByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopicById: async (topicId: string, messagingUpdateTopicByIdRequest?: MessagingUpdateTopicByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('updateTopicById', 'topicId', topicId)
            const localVarPath = `/messaging/topics/{topicId}`
                .replace(`{${"topicId"}}`, encodeURIComponent(String(topicId !== undefined ? topicId : `-topicId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateTopicByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/topics/{topicId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateTopicByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Twilio provider by its unique ID.
         * @summary Update Twilio provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateTwilioProviderRequest} [messagingUpdateTwilioProviderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwilioProvider: async (providerId: string, messagingUpdateTwilioProviderRequest?: MessagingUpdateTwilioProviderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateTwilioProvider', 'providerId', providerId)
            const localVarPath = `/messaging/providers/twilio/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateTwilioProviderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/twilio/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateTwilioProviderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Vonage provider by its unique ID.
         * @summary Update Vonage provider
         * @param {string} providerId Provider ID.
         * @param {MessagingUpdateVonageProviderByIdRequest} [messagingUpdateVonageProviderByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVonageProviderById: async (providerId: string, messagingUpdateVonageProviderByIdRequest?: MessagingUpdateVonageProviderByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateVonageProviderById', 'providerId', providerId)
            const localVarPath = `/messaging/providers/vonage/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId !== undefined ? providerId : `-providerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messagingUpdateVonageProviderByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messaging/providers/vonage/{providerId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messagingUpdateVonageProviderByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagingApi - functional programming interface
 * @export
 */
export const MessagingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Apple Push Notification service provider.
         * @summary Create APNS provider
         * @param {MessagingApiCreateApnsProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApnsProvider(requestParameters: MessagingApiCreateApnsProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateApnsProviderRequest: MessagingCreateApnsProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                authKey: requestParameters.authKey,
                authKeyId: requestParameters.authKeyId,
                teamId: requestParameters.teamId,
                bundleId: requestParameters.bundleId,
                sandbox: requestParameters.sandbox,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApnsProvider(messagingCreateApnsProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new email message.
         * @summary Create email
         * @param {MessagingApiCreateEmailMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmailMessage(requestParameters: MessagingApiCreateEmailMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const messagingCreateEmailMessageRequest: MessagingCreateEmailMessageRequest = {
                messageId: requestParameters.messageId,
                subject: requestParameters.subject,
                content: requestParameters.content,
                topics: requestParameters.topics,
                users: requestParameters.users,
                targets: requestParameters.targets,
                cc: requestParameters.cc,
                bcc: requestParameters.bcc,
                attachments: requestParameters.attachments,
                draft: requestParameters.draft,
                html: requestParameters.html,
                scheduledAt: requestParameters.scheduledAt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmailMessage(messagingCreateEmailMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Firebase Cloud Messaging provider.
         * @summary Create FCM provider
         * @param {MessagingApiCreateFcmProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFcmProvider(requestParameters: MessagingApiCreateFcmProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateFcmProviderRequest: MessagingCreateFcmProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                serviceAccountJSON: requestParameters.serviceAccountJSON,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFcmProvider(messagingCreateFcmProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Mailgun provider.
         * @summary Create Mailgun provider
         * @param {MessagingApiCreateMailgunProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMailgunProvider(requestParameters: MessagingApiCreateMailgunProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateMailgunProviderRequest: MessagingCreateMailgunProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                apiKey: requestParameters.apiKey,
                domain: requestParameters.domain,
                isEuRegion: requestParameters.isEuRegion,
                fromName: requestParameters.fromName,
                fromEmail: requestParameters.fromEmail,
                replyToName: requestParameters.replyToName,
                replyToEmail: requestParameters.replyToEmail,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMailgunProvider(messagingCreateMailgunProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new MSG91 provider.
         * @summary Create Msg91 provider
         * @param {MessagingApiCreateMsgProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMsgProvider(requestParameters: MessagingApiCreateMsgProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateMsgProviderRequest: MessagingCreateMsgProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                from: requestParameters.from,
                senderId: requestParameters.senderId,
                authKey: requestParameters.authKey,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMsgProvider(messagingCreateMsgProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new topic.
         * @summary Create topic
         * @param {MessagingApiCreateNewTopicRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewTopic(requestParameters: MessagingApiCreateNewTopicRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const messagingCreateNewTopicRequest: MessagingCreateNewTopicRequest = {
                topicId: requestParameters.topicId,
                name: requestParameters.name,
                subscribe: requestParameters.subscribe
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewTopic(messagingCreateNewTopicRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new push notification.
         * @summary Create push notification
         * @param {MessagingApiCreatePushNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPushNotification(requestParameters: MessagingApiCreatePushNotificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const messagingCreatePushNotificationRequest: MessagingCreatePushNotificationRequest = {
                title: requestParameters.title,
                messageId: requestParameters.messageId,
                body: requestParameters.body,
                topics: requestParameters.topics,
                users: requestParameters.users,
                targets: requestParameters.targets,
                data: requestParameters.data,
                action: requestParameters.action,
                image: requestParameters.image,
                icon: requestParameters.icon,
                sound: requestParameters.sound,
                color: requestParameters.color,
                tag: requestParameters.tag,
                badge: requestParameters.badge,
                draft: requestParameters.draft,
                scheduledAt: requestParameters.scheduledAt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPushNotification(messagingCreatePushNotificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Sendgrid provider.
         * @summary Create Sendgrid provider
         * @param {MessagingApiCreateSendgridProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSendgridProvider(requestParameters: MessagingApiCreateSendgridProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateSendgridProviderRequest: MessagingCreateSendgridProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                apiKey: requestParameters.apiKey,
                fromName: requestParameters.fromName,
                fromEmail: requestParameters.fromEmail,
                replyToName: requestParameters.replyToName,
                replyToEmail: requestParameters.replyToEmail,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSendgridProvider(messagingCreateSendgridProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new SMS message.
         * @summary Create SMS
         * @param {MessagingApiCreateSmsMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSmsMessage(requestParameters: MessagingApiCreateSmsMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const messagingCreateSmsMessageRequest: MessagingCreateSmsMessageRequest = {
                messageId: requestParameters.messageId,
                content: requestParameters.content,
                topics: requestParameters.topics,
                users: requestParameters.users,
                targets: requestParameters.targets,
                draft: requestParameters.draft,
                scheduledAt: requestParameters.scheduledAt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSmsMessage(messagingCreateSmsMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new SMTP provider.
         * @summary Create SMTP provider
         * @param {MessagingApiCreateSmtpProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSmtpProvider(requestParameters: MessagingApiCreateSmtpProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateSmtpProviderRequest: MessagingCreateSmtpProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                host: requestParameters.host,
                port: requestParameters.port,
                username: requestParameters.username,
                password: requestParameters.password,
                encryption: requestParameters.encryption,
                autoTLS: requestParameters.autoTLS,
                mailer: requestParameters.mailer,
                fromName: requestParameters.fromName,
                fromEmail: requestParameters.fromEmail,
                replyToName: requestParameters.replyToName,
                replyToEmail: requestParameters.replyToEmail,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSmtpProvider(messagingCreateSmtpProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new subscriber.
         * @summary Create subscriber
         * @param {MessagingApiCreateSubscriberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriber(requestParameters: MessagingApiCreateSubscriberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const messagingCreateSubscriberRequest: MessagingCreateSubscriberRequest = {
                subscriberId: requestParameters.subscriberId,
                targetId: requestParameters.targetId
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriber(requestParameters.topicId, messagingCreateSubscriberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Telesign provider.
         * @summary Create Telesign provider
         * @param {MessagingApiCreateTelesignProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTelesignProvider(requestParameters: MessagingApiCreateTelesignProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateTelesignProviderRequest: MessagingCreateTelesignProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                from: requestParameters.from,
                customerId: requestParameters.customerId,
                apiKey: requestParameters.apiKey,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTelesignProvider(messagingCreateTelesignProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Textmagic provider.
         * @summary Create Textmagic provider
         * @param {MessagingApiCreateTextmagicProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTextmagicProvider(requestParameters: MessagingApiCreateTextmagicProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateTextmagicProviderRequest: MessagingCreateTextmagicProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                from: requestParameters.from,
                username: requestParameters.username,
                apiKey: requestParameters.apiKey,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTextmagicProvider(messagingCreateTextmagicProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Twilio provider.
         * @summary Create Twilio provider
         * @param {MessagingApiCreateTwilioProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTwilioProvider(requestParameters: MessagingApiCreateTwilioProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateTwilioProviderRequest: MessagingCreateTwilioProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                from: requestParameters.from,
                accountSid: requestParameters.accountSid,
                authToken: requestParameters.authToken,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTwilioProvider(messagingCreateTwilioProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Vonage provider.
         * @summary Create Vonage provider
         * @param {MessagingApiCreateVonageProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVonageProvider(requestParameters: MessagingApiCreateVonageProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingCreateVonageProviderRequest: MessagingCreateVonageProviderRequest = {
                providerId: requestParameters.providerId,
                name: requestParameters.name,
                from: requestParameters.from,
                apiKey: requestParameters.apiKey,
                apiSecret: requestParameters.apiSecret,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVonageProvider(messagingCreateVonageProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a message. If the message is not a draft or scheduled, but has been sent, this will not recall the message.
         * @summary Delete message
         * @param {MessagingApiDeleteMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(requestParameters: MessagingApiDeleteMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(requestParameters.messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a provider by its unique ID.
         * @summary Delete provider
         * @param {MessagingApiDeleteProviderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProviderById(requestParameters: MessagingApiDeleteProviderByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProviderById(requestParameters.providerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a subscriber by its unique ID.
         * @summary Delete subscriber
         * @param {MessagingApiDeleteSubscriberByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriberById(requestParameters: MessagingApiDeleteSubscriberByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriberById(requestParameters.topicId, requestParameters.subscriberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a topic by its unique ID.
         * @summary Delete topic
         * @param {MessagingApiDeleteTopicByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTopicById(requestParameters: MessagingApiDeleteTopicByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTopicById(requestParameters.topicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a message by its unique ID. 
         * @summary Get message
         * @param {MessagingApiGetMessageByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageById(requestParameters: MessagingApiGetMessageByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageById(requestParameters.messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a provider by its unique ID. 
         * @summary Get provider
         * @param {MessagingApiGetProviderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProviderById(requestParameters: MessagingApiGetProviderByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProviderById(requestParameters.providerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a subscriber by its unique ID. 
         * @summary Get subscriber
         * @param {MessagingApiGetSubscriberByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriberById(requestParameters: MessagingApiGetSubscriberByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriberById(requestParameters.topicId, requestParameters.subscriberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a topic by its unique ID. 
         * @summary Get topic
         * @param {MessagingApiGetTopicByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicById(requestParameters: MessagingApiGetTopicByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicById(requestParameters.topicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all messages from the current Appwrite project.
         * @summary List messages
         * @param {MessagingApiListAllMessagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllMessages(requestParameters: MessagingApiListAllMessagesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllMessages(requestParameters.queries, requestParameters.search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the message activity logs listed by its unique ID.
         * @summary List message logs
         * @param {MessagingApiListMessageLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessageLogs(requestParameters: MessagingApiListMessageLogsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessageLogs(requestParameters.messageId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the provider activity logs listed by its unique ID.
         * @summary List provider logs
         * @param {MessagingApiListProviderLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProviderLogs(requestParameters: MessagingApiListProviderLogsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProviderLogs(requestParameters.providerId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all providers from the current Appwrite project.
         * @summary List providers
         * @param {MessagingApiListProvidersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProviders(requestParameters: MessagingApiListProvidersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProviders(requestParameters.queries, requestParameters.search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the subscriber activity logs listed by its unique ID.
         * @summary List subscriber logs
         * @param {MessagingApiListSubscriberLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriberLogs(requestParameters: MessagingApiListSubscriberLogsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriberLogs(requestParameters.subscriberId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all subscribers from the current Appwrite project.
         * @summary List subscribers
         * @param {MessagingApiListSubscribersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscribers(requestParameters: MessagingApiListSubscribersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriberList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscribers(requestParameters.topicId, requestParameters.queries, requestParameters.search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the targets associated with a message.
         * @summary List message targets
         * @param {MessagingApiListTargetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTargets(requestParameters: MessagingApiListTargetsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTargets(requestParameters.messageId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the topic activity logs listed by its unique ID.
         * @summary List topic logs
         * @param {MessagingApiListTopicLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTopicLogs(requestParameters: MessagingApiListTopicLogsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTopicLogs(requestParameters.topicId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all topics from the current Appwrite project.
         * @summary List topics
         * @param {MessagingApiListTopicsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTopics(requestParameters: MessagingApiListTopicsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTopics(requestParameters.queries, requestParameters.search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Apple Push Notification service provider by its unique ID.
         * @summary Update APNS provider
         * @param {MessagingApiUpdateApnsProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApnsProvider(requestParameters: MessagingApiUpdateApnsProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateApnsProviderRequest: MessagingUpdateApnsProviderRequest = {
                name: requestParameters.name,
                enabled: requestParameters.enabled,
                authKey: requestParameters.authKey,
                authKeyId: requestParameters.authKeyId,
                teamId: requestParameters.teamId,
                bundleId: requestParameters.bundleId,
                sandbox: requestParameters.sandbox
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApnsProvider(requestParameters.providerId, messagingUpdateApnsProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an email message by its unique ID. 
         * @summary Update email
         * @param {MessagingApiUpdateEmailByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailById(requestParameters: MessagingApiUpdateEmailByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const messagingUpdateEmailByIdRequest: MessagingUpdateEmailByIdRequest = {
                topics: requestParameters.topics,
                users: requestParameters.users,
                targets: requestParameters.targets,
                subject: requestParameters.subject,
                content: requestParameters.content,
                draft: requestParameters.draft,
                html: requestParameters.html,
                cc: requestParameters.cc,
                bcc: requestParameters.bcc,
                scheduledAt: requestParameters.scheduledAt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailById(requestParameters.messageId, messagingUpdateEmailByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Firebase Cloud Messaging provider by its unique ID.
         * @summary Update FCM provider
         * @param {MessagingApiUpdateFcmProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFcmProvider(requestParameters: MessagingApiUpdateFcmProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateFcmProviderRequest: MessagingUpdateFcmProviderRequest = {
                name: requestParameters.name,
                enabled: requestParameters.enabled,
                serviceAccountJSON: requestParameters.serviceAccountJSON
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFcmProvider(requestParameters.providerId, messagingUpdateFcmProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Mailgun provider by its unique ID.
         * @summary Update Mailgun provider
         * @param {MessagingApiUpdateMailgunProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMailgunProvider(requestParameters: MessagingApiUpdateMailgunProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateMailgunProviderRequest: MessagingUpdateMailgunProviderRequest = {
                name: requestParameters.name,
                apiKey: requestParameters.apiKey,
                domain: requestParameters.domain,
                isEuRegion: requestParameters.isEuRegion,
                enabled: requestParameters.enabled,
                fromName: requestParameters.fromName,
                fromEmail: requestParameters.fromEmail,
                replyToName: requestParameters.replyToName,
                replyToEmail: requestParameters.replyToEmail
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMailgunProvider(requestParameters.providerId, messagingUpdateMailgunProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a MSG91 provider by its unique ID.
         * @summary Update Msg91 provider
         * @param {MessagingApiUpdateProviderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProviderById(requestParameters: MessagingApiUpdateProviderByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateProviderByIdRequest: MessagingUpdateProviderByIdRequest = {
                name: requestParameters.name,
                enabled: requestParameters.enabled,
                senderId: requestParameters.senderId,
                authKey: requestParameters.authKey,
                from: requestParameters.from
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProviderById(requestParameters.providerId, messagingUpdateProviderByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a push notification by its unique ID. 
         * @summary Update push notification
         * @param {MessagingApiUpdatePushMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePushMessage(requestParameters: MessagingApiUpdatePushMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const messagingUpdatePushMessageRequest: MessagingUpdatePushMessageRequest = {
                title: requestParameters.title,
                topics: requestParameters.topics,
                users: requestParameters.users,
                targets: requestParameters.targets,
                body: requestParameters.body,
                data: requestParameters.data,
                action: requestParameters.action,
                image: requestParameters.image,
                icon: requestParameters.icon,
                sound: requestParameters.sound,
                color: requestParameters.color,
                tag: requestParameters.tag,
                badge: requestParameters.badge,
                draft: requestParameters.draft,
                scheduledAt: requestParameters.scheduledAt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePushMessage(requestParameters.messageId, messagingUpdatePushMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Sendgrid provider by its unique ID.
         * @summary Update Sendgrid provider
         * @param {MessagingApiUpdateSendgridProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSendgridProvider(requestParameters: MessagingApiUpdateSendgridProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateSendgridProviderRequest: MessagingUpdateSendgridProviderRequest = {
                name: requestParameters.name,
                enabled: requestParameters.enabled,
                apiKey: requestParameters.apiKey,
                fromName: requestParameters.fromName,
                fromEmail: requestParameters.fromEmail,
                replyToName: requestParameters.replyToName,
                replyToEmail: requestParameters.replyToEmail
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSendgridProvider(requestParameters.providerId, messagingUpdateSendgridProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an email message by its unique ID. 
         * @summary Update SMS
         * @param {MessagingApiUpdateSmsMessageByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSmsMessageById(requestParameters: MessagingApiUpdateSmsMessageByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const messagingUpdateSmsMessageByIdRequest: MessagingUpdateSmsMessageByIdRequest = {
                topics: requestParameters.topics,
                users: requestParameters.users,
                targets: requestParameters.targets,
                content: requestParameters.content,
                draft: requestParameters.draft,
                scheduledAt: requestParameters.scheduledAt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSmsMessageById(requestParameters.messageId, messagingUpdateSmsMessageByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a SMTP provider by its unique ID.
         * @summary Update SMTP provider
         * @param {MessagingApiUpdateSmtpProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSmtpProvider(requestParameters: MessagingApiUpdateSmtpProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateSmtpProviderRequest: MessagingUpdateSmtpProviderRequest = {
                name: requestParameters.name,
                host: requestParameters.host,
                port: requestParameters.port,
                username: requestParameters.username,
                password: requestParameters.password,
                encryption: requestParameters.encryption,
                autoTLS: requestParameters.autoTLS,
                mailer: requestParameters.mailer,
                fromName: requestParameters.fromName,
                fromEmail: requestParameters.fromEmail,
                replyToName: requestParameters.replyToName,
                replyToEmail: requestParameters.replyToEmail,
                enabled: requestParameters.enabled
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSmtpProvider(requestParameters.providerId, messagingUpdateSmtpProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Telesign provider by its unique ID.
         * @summary Update Telesign provider
         * @param {MessagingApiUpdateTelesignProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTelesignProvider(requestParameters: MessagingApiUpdateTelesignProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateTelesignProviderRequest: MessagingUpdateTelesignProviderRequest = {
                name: requestParameters.name,
                enabled: requestParameters.enabled,
                customerId: requestParameters.customerId,
                apiKey: requestParameters.apiKey,
                from: requestParameters.from
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTelesignProvider(requestParameters.providerId, messagingUpdateTelesignProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Textmagic provider by its unique ID.
         * @summary Update Textmagic provider
         * @param {MessagingApiUpdateTextmagicProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTextmagicProvider(requestParameters: MessagingApiUpdateTextmagicProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateTextmagicProviderRequest: MessagingUpdateTextmagicProviderRequest = {
                name: requestParameters.name,
                enabled: requestParameters.enabled,
                username: requestParameters.username,
                apiKey: requestParameters.apiKey,
                from: requestParameters.from
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTextmagicProvider(requestParameters.providerId, messagingUpdateTextmagicProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a topic by its unique ID. 
         * @summary Update topic
         * @param {MessagingApiUpdateTopicByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTopicById(requestParameters: MessagingApiUpdateTopicByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const messagingUpdateTopicByIdRequest: MessagingUpdateTopicByIdRequest = {
                name: requestParameters.name,
                subscribe: requestParameters.subscribe
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTopicById(requestParameters.topicId, messagingUpdateTopicByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Twilio provider by its unique ID.
         * @summary Update Twilio provider
         * @param {MessagingApiUpdateTwilioProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTwilioProvider(requestParameters: MessagingApiUpdateTwilioProviderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateTwilioProviderRequest: MessagingUpdateTwilioProviderRequest = {
                name: requestParameters.name,
                enabled: requestParameters.enabled,
                accountSid: requestParameters.accountSid,
                authToken: requestParameters.authToken,
                from: requestParameters.from
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTwilioProvider(requestParameters.providerId, messagingUpdateTwilioProviderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Vonage provider by its unique ID.
         * @summary Update Vonage provider
         * @param {MessagingApiUpdateVonageProviderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVonageProviderById(requestParameters: MessagingApiUpdateVonageProviderByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const messagingUpdateVonageProviderByIdRequest: MessagingUpdateVonageProviderByIdRequest = {
                name: requestParameters.name,
                enabled: requestParameters.enabled,
                apiKey: requestParameters.apiKey,
                apiSecret: requestParameters.apiSecret,
                from: requestParameters.from
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVonageProviderById(requestParameters.providerId, messagingUpdateVonageProviderByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessagingApi - factory interface
 * @export
 */
export const MessagingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagingApiFp(configuration)
    return {
        /**
         * Create a new Apple Push Notification service provider.
         * @summary Create APNS provider
         * @param {MessagingApiCreateApnsProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApnsProvider(requestParameters: MessagingApiCreateApnsProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createApnsProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new email message.
         * @summary Create email
         * @param {MessagingApiCreateEmailMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailMessage(requestParameters: MessagingApiCreateEmailMessageRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.createEmailMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Firebase Cloud Messaging provider.
         * @summary Create FCM provider
         * @param {MessagingApiCreateFcmProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFcmProvider(requestParameters: MessagingApiCreateFcmProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createFcmProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Mailgun provider.
         * @summary Create Mailgun provider
         * @param {MessagingApiCreateMailgunProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMailgunProvider(requestParameters: MessagingApiCreateMailgunProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createMailgunProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new MSG91 provider.
         * @summary Create Msg91 provider
         * @param {MessagingApiCreateMsgProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMsgProvider(requestParameters: MessagingApiCreateMsgProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createMsgProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new topic.
         * @summary Create topic
         * @param {MessagingApiCreateNewTopicRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTopic(requestParameters: MessagingApiCreateNewTopicRequest, options?: AxiosRequestConfig): AxiosPromise<Topic> {
            return localVarFp.createNewTopic(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new push notification.
         * @summary Create push notification
         * @param {MessagingApiCreatePushNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPushNotification(requestParameters: MessagingApiCreatePushNotificationRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.createPushNotification(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Sendgrid provider.
         * @summary Create Sendgrid provider
         * @param {MessagingApiCreateSendgridProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSendgridProvider(requestParameters: MessagingApiCreateSendgridProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createSendgridProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new SMS message.
         * @summary Create SMS
         * @param {MessagingApiCreateSmsMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSmsMessage(requestParameters: MessagingApiCreateSmsMessageRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.createSmsMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new SMTP provider.
         * @summary Create SMTP provider
         * @param {MessagingApiCreateSmtpProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSmtpProvider(requestParameters: MessagingApiCreateSmtpProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createSmtpProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new subscriber.
         * @summary Create subscriber
         * @param {MessagingApiCreateSubscriberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriber(requestParameters: MessagingApiCreateSubscriberRequest, options?: AxiosRequestConfig): AxiosPromise<Subscriber> {
            return localVarFp.createSubscriber(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Telesign provider.
         * @summary Create Telesign provider
         * @param {MessagingApiCreateTelesignProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTelesignProvider(requestParameters: MessagingApiCreateTelesignProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createTelesignProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Textmagic provider.
         * @summary Create Textmagic provider
         * @param {MessagingApiCreateTextmagicProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextmagicProvider(requestParameters: MessagingApiCreateTextmagicProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createTextmagicProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Twilio provider.
         * @summary Create Twilio provider
         * @param {MessagingApiCreateTwilioProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwilioProvider(requestParameters: MessagingApiCreateTwilioProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createTwilioProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Vonage provider.
         * @summary Create Vonage provider
         * @param {MessagingApiCreateVonageProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVonageProvider(requestParameters: MessagingApiCreateVonageProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.createVonageProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a message. If the message is not a draft or scheduled, but has been sent, this will not recall the message.
         * @summary Delete message
         * @param {MessagingApiDeleteMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(requestParameters: MessagingApiDeleteMessageRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a provider by its unique ID.
         * @summary Delete provider
         * @param {MessagingApiDeleteProviderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProviderById(requestParameters: MessagingApiDeleteProviderByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProviderById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a subscriber by its unique ID.
         * @summary Delete subscriber
         * @param {MessagingApiDeleteSubscriberByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriberById(requestParameters: MessagingApiDeleteSubscriberByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSubscriberById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a topic by its unique ID.
         * @summary Delete topic
         * @param {MessagingApiDeleteTopicByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopicById(requestParameters: MessagingApiDeleteTopicByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTopicById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a message by its unique ID. 
         * @summary Get message
         * @param {MessagingApiGetMessageByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(requestParameters: MessagingApiGetMessageByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.getMessageById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a provider by its unique ID. 
         * @summary Get provider
         * @param {MessagingApiGetProviderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderById(requestParameters: MessagingApiGetProviderByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.getProviderById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a subscriber by its unique ID. 
         * @summary Get subscriber
         * @param {MessagingApiGetSubscriberByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriberById(requestParameters: MessagingApiGetSubscriberByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Subscriber> {
            return localVarFp.getSubscriberById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a topic by its unique ID. 
         * @summary Get topic
         * @param {MessagingApiGetTopicByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicById(requestParameters: MessagingApiGetTopicByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Topic> {
            return localVarFp.getTopicById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all messages from the current Appwrite project.
         * @summary List messages
         * @param {MessagingApiListAllMessagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllMessages(requestParameters: MessagingApiListAllMessagesRequest, options?: AxiosRequestConfig): AxiosPromise<MessageList> {
            return localVarFp.listAllMessages(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the message activity logs listed by its unique ID.
         * @summary List message logs
         * @param {MessagingApiListMessageLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessageLogs(requestParameters: MessagingApiListMessageLogsRequest, options?: AxiosRequestConfig): AxiosPromise<LogList> {
            return localVarFp.listMessageLogs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the provider activity logs listed by its unique ID.
         * @summary List provider logs
         * @param {MessagingApiListProviderLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviderLogs(requestParameters: MessagingApiListProviderLogsRequest, options?: AxiosRequestConfig): AxiosPromise<LogList> {
            return localVarFp.listProviderLogs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all providers from the current Appwrite project.
         * @summary List providers
         * @param {MessagingApiListProvidersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviders(requestParameters: MessagingApiListProvidersRequest, options?: AxiosRequestConfig): AxiosPromise<ProviderList> {
            return localVarFp.listProviders(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscriber activity logs listed by its unique ID.
         * @summary List subscriber logs
         * @param {MessagingApiListSubscriberLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriberLogs(requestParameters: MessagingApiListSubscriberLogsRequest, options?: AxiosRequestConfig): AxiosPromise<LogList> {
            return localVarFp.listSubscriberLogs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all subscribers from the current Appwrite project.
         * @summary List subscribers
         * @param {MessagingApiListSubscribersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscribers(requestParameters: MessagingApiListSubscribersRequest, options?: AxiosRequestConfig): AxiosPromise<SubscriberList> {
            return localVarFp.listSubscribers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the targets associated with a message.
         * @summary List message targets
         * @param {MessagingApiListTargetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTargets(requestParameters: MessagingApiListTargetsRequest, options?: AxiosRequestConfig): AxiosPromise<TargetList> {
            return localVarFp.listTargets(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the topic activity logs listed by its unique ID.
         * @summary List topic logs
         * @param {MessagingApiListTopicLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopicLogs(requestParameters: MessagingApiListTopicLogsRequest, options?: AxiosRequestConfig): AxiosPromise<LogList> {
            return localVarFp.listTopicLogs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all topics from the current Appwrite project.
         * @summary List topics
         * @param {MessagingApiListTopicsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopics(requestParameters: MessagingApiListTopicsRequest, options?: AxiosRequestConfig): AxiosPromise<TopicList> {
            return localVarFp.listTopics(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Apple Push Notification service provider by its unique ID.
         * @summary Update APNS provider
         * @param {MessagingApiUpdateApnsProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApnsProvider(requestParameters: MessagingApiUpdateApnsProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateApnsProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an email message by its unique ID. 
         * @summary Update email
         * @param {MessagingApiUpdateEmailByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailById(requestParameters: MessagingApiUpdateEmailByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.updateEmailById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Firebase Cloud Messaging provider by its unique ID.
         * @summary Update FCM provider
         * @param {MessagingApiUpdateFcmProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFcmProvider(requestParameters: MessagingApiUpdateFcmProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateFcmProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Mailgun provider by its unique ID.
         * @summary Update Mailgun provider
         * @param {MessagingApiUpdateMailgunProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMailgunProvider(requestParameters: MessagingApiUpdateMailgunProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateMailgunProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a MSG91 provider by its unique ID.
         * @summary Update Msg91 provider
         * @param {MessagingApiUpdateProviderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProviderById(requestParameters: MessagingApiUpdateProviderByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateProviderById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a push notification by its unique ID. 
         * @summary Update push notification
         * @param {MessagingApiUpdatePushMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePushMessage(requestParameters: MessagingApiUpdatePushMessageRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.updatePushMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Sendgrid provider by its unique ID.
         * @summary Update Sendgrid provider
         * @param {MessagingApiUpdateSendgridProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSendgridProvider(requestParameters: MessagingApiUpdateSendgridProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateSendgridProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an email message by its unique ID. 
         * @summary Update SMS
         * @param {MessagingApiUpdateSmsMessageByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSmsMessageById(requestParameters: MessagingApiUpdateSmsMessageByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.updateSmsMessageById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a SMTP provider by its unique ID.
         * @summary Update SMTP provider
         * @param {MessagingApiUpdateSmtpProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSmtpProvider(requestParameters: MessagingApiUpdateSmtpProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateSmtpProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Telesign provider by its unique ID.
         * @summary Update Telesign provider
         * @param {MessagingApiUpdateTelesignProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTelesignProvider(requestParameters: MessagingApiUpdateTelesignProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateTelesignProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Textmagic provider by its unique ID.
         * @summary Update Textmagic provider
         * @param {MessagingApiUpdateTextmagicProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextmagicProvider(requestParameters: MessagingApiUpdateTextmagicProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateTextmagicProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a topic by its unique ID. 
         * @summary Update topic
         * @param {MessagingApiUpdateTopicByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopicById(requestParameters: MessagingApiUpdateTopicByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Topic> {
            return localVarFp.updateTopicById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Twilio provider by its unique ID.
         * @summary Update Twilio provider
         * @param {MessagingApiUpdateTwilioProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwilioProvider(requestParameters: MessagingApiUpdateTwilioProviderRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateTwilioProvider(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Vonage provider by its unique ID.
         * @summary Update Vonage provider
         * @param {MessagingApiUpdateVonageProviderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVonageProviderById(requestParameters: MessagingApiUpdateVonageProviderByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Provider> {
            return localVarFp.updateVonageProviderById(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApnsProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateApnsProviderRequest
 */
export type MessagingApiCreateApnsProviderRequest = {
    
} & MessagingCreateApnsProviderRequest

/**
 * Request parameters for createEmailMessage operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateEmailMessageRequest
 */
export type MessagingApiCreateEmailMessageRequest = {
    
} & MessagingCreateEmailMessageRequest

/**
 * Request parameters for createFcmProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateFcmProviderRequest
 */
export type MessagingApiCreateFcmProviderRequest = {
    
} & MessagingCreateFcmProviderRequest

/**
 * Request parameters for createMailgunProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateMailgunProviderRequest
 */
export type MessagingApiCreateMailgunProviderRequest = {
    
} & MessagingCreateMailgunProviderRequest

/**
 * Request parameters for createMsgProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateMsgProviderRequest
 */
export type MessagingApiCreateMsgProviderRequest = {
    
} & MessagingCreateMsgProviderRequest

/**
 * Request parameters for createNewTopic operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateNewTopicRequest
 */
export type MessagingApiCreateNewTopicRequest = {
    
} & MessagingCreateNewTopicRequest

/**
 * Request parameters for createPushNotification operation in MessagingApi.
 * @export
 * @interface MessagingApiCreatePushNotificationRequest
 */
export type MessagingApiCreatePushNotificationRequest = {
    
} & MessagingCreatePushNotificationRequest

/**
 * Request parameters for createSendgridProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateSendgridProviderRequest
 */
export type MessagingApiCreateSendgridProviderRequest = {
    
} & MessagingCreateSendgridProviderRequest

/**
 * Request parameters for createSmsMessage operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateSmsMessageRequest
 */
export type MessagingApiCreateSmsMessageRequest = {
    
} & MessagingCreateSmsMessageRequest

/**
 * Request parameters for createSmtpProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateSmtpProviderRequest
 */
export type MessagingApiCreateSmtpProviderRequest = {
    
} & MessagingCreateSmtpProviderRequest

/**
 * Request parameters for createSubscriber operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateSubscriberRequest
 */
export type MessagingApiCreateSubscriberRequest = {
    
    /**
    * Topic ID. The topic ID to subscribe to.
    * @type {string}
    * @memberof MessagingApiCreateSubscriber
    */
    readonly topicId: string
    
} & MessagingCreateSubscriberRequest

/**
 * Request parameters for createTelesignProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateTelesignProviderRequest
 */
export type MessagingApiCreateTelesignProviderRequest = {
    
} & MessagingCreateTelesignProviderRequest

/**
 * Request parameters for createTextmagicProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateTextmagicProviderRequest
 */
export type MessagingApiCreateTextmagicProviderRequest = {
    
} & MessagingCreateTextmagicProviderRequest

/**
 * Request parameters for createTwilioProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateTwilioProviderRequest
 */
export type MessagingApiCreateTwilioProviderRequest = {
    
} & MessagingCreateTwilioProviderRequest

/**
 * Request parameters for createVonageProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiCreateVonageProviderRequest
 */
export type MessagingApiCreateVonageProviderRequest = {
    
} & MessagingCreateVonageProviderRequest

/**
 * Request parameters for deleteMessage operation in MessagingApi.
 * @export
 * @interface MessagingApiDeleteMessageRequest
 */
export type MessagingApiDeleteMessageRequest = {
    
    /**
    * Message ID.
    * @type {string}
    * @memberof MessagingApiDeleteMessage
    */
    readonly messageId: string
    
}

/**
 * Request parameters for deleteProviderById operation in MessagingApi.
 * @export
 * @interface MessagingApiDeleteProviderByIdRequest
 */
export type MessagingApiDeleteProviderByIdRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiDeleteProviderById
    */
    readonly providerId: string
    
}

/**
 * Request parameters for deleteSubscriberById operation in MessagingApi.
 * @export
 * @interface MessagingApiDeleteSubscriberByIdRequest
 */
export type MessagingApiDeleteSubscriberByIdRequest = {
    
    /**
    * Topic ID. The topic ID subscribed to.
    * @type {string}
    * @memberof MessagingApiDeleteSubscriberById
    */
    readonly topicId: string
    
    /**
    * Subscriber ID.
    * @type {string}
    * @memberof MessagingApiDeleteSubscriberById
    */
    readonly subscriberId: string
    
}

/**
 * Request parameters for deleteTopicById operation in MessagingApi.
 * @export
 * @interface MessagingApiDeleteTopicByIdRequest
 */
export type MessagingApiDeleteTopicByIdRequest = {
    
    /**
    * Topic ID.
    * @type {string}
    * @memberof MessagingApiDeleteTopicById
    */
    readonly topicId: string
    
}

/**
 * Request parameters for getMessageById operation in MessagingApi.
 * @export
 * @interface MessagingApiGetMessageByIdRequest
 */
export type MessagingApiGetMessageByIdRequest = {
    
    /**
    * Message ID.
    * @type {string}
    * @memberof MessagingApiGetMessageById
    */
    readonly messageId: string
    
}

/**
 * Request parameters for getProviderById operation in MessagingApi.
 * @export
 * @interface MessagingApiGetProviderByIdRequest
 */
export type MessagingApiGetProviderByIdRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiGetProviderById
    */
    readonly providerId: string
    
}

/**
 * Request parameters for getSubscriberById operation in MessagingApi.
 * @export
 * @interface MessagingApiGetSubscriberByIdRequest
 */
export type MessagingApiGetSubscriberByIdRequest = {
    
    /**
    * Topic ID. The topic ID subscribed to.
    * @type {string}
    * @memberof MessagingApiGetSubscriberById
    */
    readonly topicId: string
    
    /**
    * Subscriber ID.
    * @type {string}
    * @memberof MessagingApiGetSubscriberById
    */
    readonly subscriberId: string
    
}

/**
 * Request parameters for getTopicById operation in MessagingApi.
 * @export
 * @interface MessagingApiGetTopicByIdRequest
 */
export type MessagingApiGetTopicByIdRequest = {
    
    /**
    * Topic ID.
    * @type {string}
    * @memberof MessagingApiGetTopicById
    */
    readonly topicId: string
    
}

/**
 * Request parameters for listAllMessages operation in MessagingApi.
 * @export
 * @interface MessagingApiListAllMessagesRequest
 */
export type MessagingApiListAllMessagesRequest = {
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: scheduledAt, deliveredAt, deliveredTotal, status, description, providerType
    * @type {Array<string>}
    * @memberof MessagingApiListAllMessages
    */
    readonly queries?: Array<string>
    
    /**
    * Search term to filter your list results. Max length: 256 chars.
    * @type {string}
    * @memberof MessagingApiListAllMessages
    */
    readonly search?: string
    
}

/**
 * Request parameters for listMessageLogs operation in MessagingApi.
 * @export
 * @interface MessagingApiListMessageLogsRequest
 */
export type MessagingApiListMessageLogsRequest = {
    
    /**
    * Message ID.
    * @type {string}
    * @memberof MessagingApiListMessageLogs
    */
    readonly messageId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
    * @type {Array<string>}
    * @memberof MessagingApiListMessageLogs
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for listProviderLogs operation in MessagingApi.
 * @export
 * @interface MessagingApiListProviderLogsRequest
 */
export type MessagingApiListProviderLogsRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiListProviderLogs
    */
    readonly providerId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
    * @type {Array<string>}
    * @memberof MessagingApiListProviderLogs
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for listProviders operation in MessagingApi.
 * @export
 * @interface MessagingApiListProvidersRequest
 */
export type MessagingApiListProvidersRequest = {
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, provider, type, enabled
    * @type {Array<string>}
    * @memberof MessagingApiListProviders
    */
    readonly queries?: Array<string>
    
    /**
    * Search term to filter your list results. Max length: 256 chars.
    * @type {string}
    * @memberof MessagingApiListProviders
    */
    readonly search?: string
    
}

/**
 * Request parameters for listSubscriberLogs operation in MessagingApi.
 * @export
 * @interface MessagingApiListSubscriberLogsRequest
 */
export type MessagingApiListSubscriberLogsRequest = {
    
    /**
    * Subscriber ID.
    * @type {string}
    * @memberof MessagingApiListSubscriberLogs
    */
    readonly subscriberId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
    * @type {Array<string>}
    * @memberof MessagingApiListSubscriberLogs
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for listSubscribers operation in MessagingApi.
 * @export
 * @interface MessagingApiListSubscribersRequest
 */
export type MessagingApiListSubscribersRequest = {
    
    /**
    * Topic ID. The topic ID subscribed to.
    * @type {string}
    * @memberof MessagingApiListSubscribers
    */
    readonly topicId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, provider, type, enabled
    * @type {Array<string>}
    * @memberof MessagingApiListSubscribers
    */
    readonly queries?: Array<string>
    
    /**
    * Search term to filter your list results. Max length: 256 chars.
    * @type {string}
    * @memberof MessagingApiListSubscribers
    */
    readonly search?: string
    
}

/**
 * Request parameters for listTargets operation in MessagingApi.
 * @export
 * @interface MessagingApiListTargetsRequest
 */
export type MessagingApiListTargetsRequest = {
    
    /**
    * Message ID.
    * @type {string}
    * @memberof MessagingApiListTargets
    */
    readonly messageId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: userId, providerId, identifier, providerType
    * @type {Array<string>}
    * @memberof MessagingApiListTargets
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for listTopicLogs operation in MessagingApi.
 * @export
 * @interface MessagingApiListTopicLogsRequest
 */
export type MessagingApiListTopicLogsRequest = {
    
    /**
    * Topic ID.
    * @type {string}
    * @memberof MessagingApiListTopicLogs
    */
    readonly topicId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
    * @type {Array<string>}
    * @memberof MessagingApiListTopicLogs
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for listTopics operation in MessagingApi.
 * @export
 * @interface MessagingApiListTopicsRequest
 */
export type MessagingApiListTopicsRequest = {
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, description, emailTotal, smsTotal, pushTotal
    * @type {Array<string>}
    * @memberof MessagingApiListTopics
    */
    readonly queries?: Array<string>
    
    /**
    * Search term to filter your list results. Max length: 256 chars.
    * @type {string}
    * @memberof MessagingApiListTopics
    */
    readonly search?: string
    
}

/**
 * Request parameters for updateApnsProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateApnsProviderRequest
 */
export type MessagingApiUpdateApnsProviderRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateApnsProvider
    */
    readonly providerId: string
    
} & MessagingUpdateApnsProviderRequest

/**
 * Request parameters for updateEmailById operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateEmailByIdRequest
 */
export type MessagingApiUpdateEmailByIdRequest = {
    
    /**
    * Message ID.
    * @type {string}
    * @memberof MessagingApiUpdateEmailById
    */
    readonly messageId: string
    
} & MessagingUpdateEmailByIdRequest

/**
 * Request parameters for updateFcmProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateFcmProviderRequest
 */
export type MessagingApiUpdateFcmProviderRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateFcmProvider
    */
    readonly providerId: string
    
} & MessagingUpdateFcmProviderRequest

/**
 * Request parameters for updateMailgunProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateMailgunProviderRequest
 */
export type MessagingApiUpdateMailgunProviderRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateMailgunProvider
    */
    readonly providerId: string
    
} & MessagingUpdateMailgunProviderRequest

/**
 * Request parameters for updateProviderById operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateProviderByIdRequest
 */
export type MessagingApiUpdateProviderByIdRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateProviderById
    */
    readonly providerId: string
    
} & MessagingUpdateProviderByIdRequest

/**
 * Request parameters for updatePushMessage operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdatePushMessageRequest
 */
export type MessagingApiUpdatePushMessageRequest = {
    
    /**
    * Message ID.
    * @type {string}
    * @memberof MessagingApiUpdatePushMessage
    */
    readonly messageId: string
    
} & MessagingUpdatePushMessageRequest

/**
 * Request parameters for updateSendgridProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateSendgridProviderRequest
 */
export type MessagingApiUpdateSendgridProviderRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateSendgridProvider
    */
    readonly providerId: string
    
} & MessagingUpdateSendgridProviderRequest

/**
 * Request parameters for updateSmsMessageById operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateSmsMessageByIdRequest
 */
export type MessagingApiUpdateSmsMessageByIdRequest = {
    
    /**
    * Message ID.
    * @type {string}
    * @memberof MessagingApiUpdateSmsMessageById
    */
    readonly messageId: string
    
} & MessagingUpdateSmsMessageByIdRequest

/**
 * Request parameters for updateSmtpProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateSmtpProviderRequest
 */
export type MessagingApiUpdateSmtpProviderRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateSmtpProvider
    */
    readonly providerId: string
    
} & MessagingUpdateSmtpProviderRequest

/**
 * Request parameters for updateTelesignProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateTelesignProviderRequest
 */
export type MessagingApiUpdateTelesignProviderRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateTelesignProvider
    */
    readonly providerId: string
    
} & MessagingUpdateTelesignProviderRequest

/**
 * Request parameters for updateTextmagicProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateTextmagicProviderRequest
 */
export type MessagingApiUpdateTextmagicProviderRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateTextmagicProvider
    */
    readonly providerId: string
    
} & MessagingUpdateTextmagicProviderRequest

/**
 * Request parameters for updateTopicById operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateTopicByIdRequest
 */
export type MessagingApiUpdateTopicByIdRequest = {
    
    /**
    * Topic ID.
    * @type {string}
    * @memberof MessagingApiUpdateTopicById
    */
    readonly topicId: string
    
} & MessagingUpdateTopicByIdRequest

/**
 * Request parameters for updateTwilioProvider operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateTwilioProviderRequest
 */
export type MessagingApiUpdateTwilioProviderRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateTwilioProvider
    */
    readonly providerId: string
    
} & MessagingUpdateTwilioProviderRequest

/**
 * Request parameters for updateVonageProviderById operation in MessagingApi.
 * @export
 * @interface MessagingApiUpdateVonageProviderByIdRequest
 */
export type MessagingApiUpdateVonageProviderByIdRequest = {
    
    /**
    * Provider ID.
    * @type {string}
    * @memberof MessagingApiUpdateVonageProviderById
    */
    readonly providerId: string
    
} & MessagingUpdateVonageProviderByIdRequest

/**
 * MessagingApiGenerated - object-oriented interface
 * @export
 * @class MessagingApiGenerated
 * @extends {BaseAPI}
 */
export class MessagingApiGenerated extends BaseAPI {
    /**
     * Create a new Apple Push Notification service provider.
     * @summary Create APNS provider
     * @param {MessagingApiCreateApnsProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createApnsProvider(requestParameters: MessagingApiCreateApnsProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createApnsProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new email message.
     * @summary Create email
     * @param {MessagingApiCreateEmailMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createEmailMessage(requestParameters: MessagingApiCreateEmailMessageRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createEmailMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Firebase Cloud Messaging provider.
     * @summary Create FCM provider
     * @param {MessagingApiCreateFcmProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createFcmProvider(requestParameters: MessagingApiCreateFcmProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createFcmProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Mailgun provider.
     * @summary Create Mailgun provider
     * @param {MessagingApiCreateMailgunProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createMailgunProvider(requestParameters: MessagingApiCreateMailgunProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createMailgunProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new MSG91 provider.
     * @summary Create Msg91 provider
     * @param {MessagingApiCreateMsgProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createMsgProvider(requestParameters: MessagingApiCreateMsgProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createMsgProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new topic.
     * @summary Create topic
     * @param {MessagingApiCreateNewTopicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createNewTopic(requestParameters: MessagingApiCreateNewTopicRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createNewTopic(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new push notification.
     * @summary Create push notification
     * @param {MessagingApiCreatePushNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createPushNotification(requestParameters: MessagingApiCreatePushNotificationRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createPushNotification(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Sendgrid provider.
     * @summary Create Sendgrid provider
     * @param {MessagingApiCreateSendgridProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createSendgridProvider(requestParameters: MessagingApiCreateSendgridProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createSendgridProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new SMS message.
     * @summary Create SMS
     * @param {MessagingApiCreateSmsMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createSmsMessage(requestParameters: MessagingApiCreateSmsMessageRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createSmsMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new SMTP provider.
     * @summary Create SMTP provider
     * @param {MessagingApiCreateSmtpProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createSmtpProvider(requestParameters: MessagingApiCreateSmtpProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createSmtpProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new subscriber.
     * @summary Create subscriber
     * @param {MessagingApiCreateSubscriberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createSubscriber(requestParameters: MessagingApiCreateSubscriberRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createSubscriber(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Telesign provider.
     * @summary Create Telesign provider
     * @param {MessagingApiCreateTelesignProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createTelesignProvider(requestParameters: MessagingApiCreateTelesignProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createTelesignProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Textmagic provider.
     * @summary Create Textmagic provider
     * @param {MessagingApiCreateTextmagicProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createTextmagicProvider(requestParameters: MessagingApiCreateTextmagicProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createTextmagicProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Twilio provider.
     * @summary Create Twilio provider
     * @param {MessagingApiCreateTwilioProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createTwilioProvider(requestParameters: MessagingApiCreateTwilioProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createTwilioProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Vonage provider.
     * @summary Create Vonage provider
     * @param {MessagingApiCreateVonageProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public createVonageProvider(requestParameters: MessagingApiCreateVonageProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).createVonageProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a message. If the message is not a draft or scheduled, but has been sent, this will not recall the message.
     * @summary Delete message
     * @param {MessagingApiDeleteMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public deleteMessage(requestParameters: MessagingApiDeleteMessageRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).deleteMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a provider by its unique ID.
     * @summary Delete provider
     * @param {MessagingApiDeleteProviderByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public deleteProviderById(requestParameters: MessagingApiDeleteProviderByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).deleteProviderById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a subscriber by its unique ID.
     * @summary Delete subscriber
     * @param {MessagingApiDeleteSubscriberByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public deleteSubscriberById(requestParameters: MessagingApiDeleteSubscriberByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).deleteSubscriberById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a topic by its unique ID.
     * @summary Delete topic
     * @param {MessagingApiDeleteTopicByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public deleteTopicById(requestParameters: MessagingApiDeleteTopicByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).deleteTopicById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a message by its unique ID. 
     * @summary Get message
     * @param {MessagingApiGetMessageByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public getMessageById(requestParameters: MessagingApiGetMessageByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).getMessageById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a provider by its unique ID. 
     * @summary Get provider
     * @param {MessagingApiGetProviderByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public getProviderById(requestParameters: MessagingApiGetProviderByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).getProviderById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a subscriber by its unique ID. 
     * @summary Get subscriber
     * @param {MessagingApiGetSubscriberByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public getSubscriberById(requestParameters: MessagingApiGetSubscriberByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).getSubscriberById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a topic by its unique ID. 
     * @summary Get topic
     * @param {MessagingApiGetTopicByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public getTopicById(requestParameters: MessagingApiGetTopicByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).getTopicById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all messages from the current Appwrite project.
     * @summary List messages
     * @param {MessagingApiListAllMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listAllMessages(requestParameters: MessagingApiListAllMessagesRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listAllMessages(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the message activity logs listed by its unique ID.
     * @summary List message logs
     * @param {MessagingApiListMessageLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listMessageLogs(requestParameters: MessagingApiListMessageLogsRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listMessageLogs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the provider activity logs listed by its unique ID.
     * @summary List provider logs
     * @param {MessagingApiListProviderLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listProviderLogs(requestParameters: MessagingApiListProviderLogsRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listProviderLogs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all providers from the current Appwrite project.
     * @summary List providers
     * @param {MessagingApiListProvidersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listProviders(requestParameters: MessagingApiListProvidersRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listProviders(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscriber activity logs listed by its unique ID.
     * @summary List subscriber logs
     * @param {MessagingApiListSubscriberLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listSubscriberLogs(requestParameters: MessagingApiListSubscriberLogsRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listSubscriberLogs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all subscribers from the current Appwrite project.
     * @summary List subscribers
     * @param {MessagingApiListSubscribersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listSubscribers(requestParameters: MessagingApiListSubscribersRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listSubscribers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the targets associated with a message.
     * @summary List message targets
     * @param {MessagingApiListTargetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listTargets(requestParameters: MessagingApiListTargetsRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listTargets(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the topic activity logs listed by its unique ID.
     * @summary List topic logs
     * @param {MessagingApiListTopicLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listTopicLogs(requestParameters: MessagingApiListTopicLogsRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listTopicLogs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all topics from the current Appwrite project.
     * @summary List topics
     * @param {MessagingApiListTopicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public listTopics(requestParameters: MessagingApiListTopicsRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).listTopics(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Apple Push Notification service provider by its unique ID.
     * @summary Update APNS provider
     * @param {MessagingApiUpdateApnsProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateApnsProvider(requestParameters: MessagingApiUpdateApnsProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateApnsProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an email message by its unique ID. 
     * @summary Update email
     * @param {MessagingApiUpdateEmailByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateEmailById(requestParameters: MessagingApiUpdateEmailByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateEmailById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Firebase Cloud Messaging provider by its unique ID.
     * @summary Update FCM provider
     * @param {MessagingApiUpdateFcmProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateFcmProvider(requestParameters: MessagingApiUpdateFcmProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateFcmProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Mailgun provider by its unique ID.
     * @summary Update Mailgun provider
     * @param {MessagingApiUpdateMailgunProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateMailgunProvider(requestParameters: MessagingApiUpdateMailgunProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateMailgunProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a MSG91 provider by its unique ID.
     * @summary Update Msg91 provider
     * @param {MessagingApiUpdateProviderByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateProviderById(requestParameters: MessagingApiUpdateProviderByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateProviderById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a push notification by its unique ID. 
     * @summary Update push notification
     * @param {MessagingApiUpdatePushMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updatePushMessage(requestParameters: MessagingApiUpdatePushMessageRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updatePushMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Sendgrid provider by its unique ID.
     * @summary Update Sendgrid provider
     * @param {MessagingApiUpdateSendgridProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateSendgridProvider(requestParameters: MessagingApiUpdateSendgridProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateSendgridProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an email message by its unique ID. 
     * @summary Update SMS
     * @param {MessagingApiUpdateSmsMessageByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateSmsMessageById(requestParameters: MessagingApiUpdateSmsMessageByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateSmsMessageById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a SMTP provider by its unique ID.
     * @summary Update SMTP provider
     * @param {MessagingApiUpdateSmtpProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateSmtpProvider(requestParameters: MessagingApiUpdateSmtpProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateSmtpProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Telesign provider by its unique ID.
     * @summary Update Telesign provider
     * @param {MessagingApiUpdateTelesignProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateTelesignProvider(requestParameters: MessagingApiUpdateTelesignProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateTelesignProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Textmagic provider by its unique ID.
     * @summary Update Textmagic provider
     * @param {MessagingApiUpdateTextmagicProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateTextmagicProvider(requestParameters: MessagingApiUpdateTextmagicProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateTextmagicProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a topic by its unique ID. 
     * @summary Update topic
     * @param {MessagingApiUpdateTopicByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateTopicById(requestParameters: MessagingApiUpdateTopicByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateTopicById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Twilio provider by its unique ID.
     * @summary Update Twilio provider
     * @param {MessagingApiUpdateTwilioProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateTwilioProvider(requestParameters: MessagingApiUpdateTwilioProviderRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateTwilioProvider(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Vonage provider by its unique ID.
     * @summary Update Vonage provider
     * @param {MessagingApiUpdateVonageProviderByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingApiGenerated
     */
    public updateVonageProviderById(requestParameters: MessagingApiUpdateVonageProviderByIdRequest, options?: AxiosRequestConfig) {
        return MessagingApiFp(this.configuration).updateVonageProviderById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
